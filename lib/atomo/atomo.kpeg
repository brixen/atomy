           line = { current_line }

             sp = (" " | "\n" | comment)*
         sig_sp = (" " | "\n" | comment)+

    ident_start = < /[[a-z]_]/ > { text }
  ident_letters = < /((?!`)[[:alnum:]\$\+\<=\>\^`~_!@#%&*\-.\/\?])*/ > { text }

       op_start = < /(?![@#\$~`])[\$\+\<=\>\^`~_!@#%&*\-.\/\?:]/ > { text }
     op_letters = < /((?!`)[\$\+\<=\>\^`~_!@#%&*\-.\/\?:])*/ > { text }

  f_ident_start = < /(?![&@#\$~`:])[[:alpha:]\$\+\<=\>\^`~_!@#%&*\-.\/\?]/ > { text }

       operator = < op_start op_letters > { text }

     identifier = < ident_start ident_letters > { text }
   f_identifier = < f_ident_start ident_letters > { text }

        grouped = "(" sp expression:x sp ")" { x }

        comment = /--.*?$/ | multi_comment

  multi_comment = "{-" in_multi
       in_multi = /[^\-\{\}]*/ "-}"
                | /[^\-\{\}]*/ "{-" in_multi /[^\-\{\}]*/ "-}"
                | /[^\-\{\}]*/ /[-{}]/ in_multi

          delim = "," | ";"

     expression = level4

    expressions = expression:x (sp delim sp expression:y)*:xs delim?
                    { [x] + Array(xs) }

         level1 = true
                | false
                | self
                | nil
                | number
                | macro
                | for_macro
                | quote
                | quasi_quote
                | unquote
                | string
                | particle
                | block_pass
                | constant
                | variable
                | g_variable
                | c_variable
                | i_variable
                | tuple
                | grouped
                | block
                | list
         level2 = unary_send | level1
         level3 = keyword_send | level2
         level4 = binary_send | level3

           true = line:line "True" { Atomo::AST::Primitive.new(line, :true) }
          false = line:line "False" { Atomo::AST::Primitive.new(line, :false) }

           self = line:line "self" { Atomo::AST::Primitive.new(line, :self) }

            nil = line:line "nil" { Atomo::AST::Primitive.new(line, :nil) }

         number = line:line < /[\+\-]?\d+/ >
                    { Atomo::AST::Primitive.new(line, text.to_i) }
                | line:line < /[\+\-]?0[oO][\da-fA-F]+/ >
                    { Atomo::AST::Primitive.new(line, text.to_i(8)) }
                | line:line < /[\+\-]?0[xX][0-7]+/ >
                    { Atomo::AST::Primitive.new(line, text.to_i(16)) }
                | line:line < /[\+\-]?\d+(\.\d+)?[eE][\+\-]?\d+/ >
                    { Atomo::AST::Primitive.new(line, text.to_f) }

          macro = line:line "macro" sig_sp "(" sp expression:p sp ")" sp expression:b
                    { b; Atomo::AST::Macro.new(line, p, b) }

      for_macro = line:line "for-macro" sig_sp expression:b
                    { Atomo::AST::ForMacro.new(line, b) }

          quote = line:line "'" level1:e { Atomo::AST::Quote.new(line, e) }
    quasi_quote = line:line "`" level1:e { Atomo::AST::QuasiQuote.new(line, e) }
        unquote = line:line "~" level1:e { Atomo::AST::Unquote.new(line, e) }

        escapes = "n" { "\n" }
                | "s" { " " }
                | "r" { "\r" }
                | "t" { "\t" }
                | "v" { "\v" }
                | "f" { "\f" }
                | "b" { "\b" }
                | "a" { "\a" }
                | "e" { "\e" }
                | "\\" { "\\" }
                | "\"" { "\"" }
                | "BS" { "\b" }
                | "HT" { "\t" }
                | "LF" { "\n" }
                | "VT" { "\v" }
                | "FF" { "\f" }
                | "CR" { "\r" }
                | "SO" { "\016" }
                | "SI" { "\017" }
                | "EM" { "\031" }
                | "FS" { "\034" }
                | "GS" { "\035" }
                | "RS" { "\036" }
                | "US" { "\037" }
                | "SP" { " " }
                | "NUL" { "\000" }
                | "SOH" { "\001" }
                | "STX" { "\002" }
                | "ETX" { "\003" }
                | "EOT" { "\004" }
                | "ENQ" { "\005" }
                | "ACK" { "\006" }
                | "BEL" { "\a" }
                | "DLE" { "\020" }
                | "DC1" { "\021" }
                | "DC2" { "\022" }
                | "DC3" { "\023" }
                | "DC4" { "\024" }
                | "NAK" { "\025" }
                | "SYN" { "\026" }
                | "ETB" { "\027" }
                | "CAN" { "\030" }
                | "SUB" { "\032" }
                | "ESC" { "\e" }
                | "DEL" { "\177" }

 number_escapes = /[xX]/ < /[0-9a-fA-F]{1,5}/ > { text.to_i(16).chr }
                | < /\d{1,6}/ > { text.to_i.chr }
                | /[oO]/ < /[0-7]{1,7}/ > { text.to_i(16).chr }
                | /[uU]/ < /[0-9a-fA-F]{4}/ > { text.to_i(16).chr }

         escape = number_escapes | escapes

        str_seq = < /[^\\"]+/ > { text }
         string = line:line "\"" (("\\" escape) | str_seq)*:c "\""
                    { Atomo::AST::String.new(line, c.join) }

       particle = line:line "#" f_identifier:n { Atomo::AST::Particle.new(line, n) }

     block_pass = line:line "&" level1:b { Atomo::AST::BlockPass.new(line, b) }

  constant_name = < /[A-Z][a-zA-Z0-9_]*/ > { text }
       constant = line:line constant_name:m ("::" constant_name)*:s
                    { Atomo::AST::Constant.new(line, [m] + Array(s)) }

       variable = line:line identifier:n { Atomo::AST::Variable.new(line, n) }
     g_variable = line:line "$" f_identifier:n { Atomo::AST::GlobalVariable.new(line, n) }
     c_variable = line:line "@@" f_identifier:n { Atomo::AST::ClassVariable.new(line, n) }
     i_variable = line:line "@" f_identifier:n { Atomo::AST::InstanceVariable.new(line, n) }

          tuple = line:line "(" sp expression:e sp delim sp expressions:es sp ")"
                    { Atomo::AST::Tuple.new(line, [e] + Array(es)) }
                | line:line "(" sp ")"
                    { Atomo::AST::Tuple.new(line, []) }

     block_args = (sp level1:n)+:as sp "|" { as }
          block = line:line "{" block_args?:as sp expressions?:es sp "}"
                    { Atomo::AST::Block.new(line, Array(es), Array(as)) }

           list = line:line "[" sp expressions?:es sp "]"
                    { Atomo::AST::List.new(line, Array(es)) }

     unary_args = "(" sp expressions?:as sp ")" { as }
     unary_send = line:line unary_send:r sig_sp identifier:n !":" unary_args?:as (sp block)?:b
                    { Atomo::AST::UnarySend.new(line, r, n, Array(as), b) }
                | line:line level1:r sig_sp identifier:n !":" unary_args?:as (sp block)?:b
                    { Atomo::AST::UnarySend.new(line, r, n, Array(as), b) }
                | line:line identifier:n unary_args:as (sp block)?:b
                    { Atomo::AST::UnarySend.new(line,
                        Atomo::AST::Primitive.new(line, :self),
                        n,
                        Array(as),
                        b,
                        true
                      )
                    }

   keyword_pair = sp identifier:n ":" sp level2:v { [n, v] }
   keyword_args = keyword_pair+:as {
                    pairs = Array(as)
                    name = ""
                    args = []

                    pairs.each do |n, v|
                      name << "#{n}:"
                      args << v
                    end

                    [name, args]
                  }

   keyword_send = line:line level2:r sig_sp keyword_args:as
                    { Atomo::AST::KeywordSend.new(line, r, as.first, as.last) }
                | line:line keyword_args:as
                    { Atomo::AST::KeywordSend.new(line,
                        Atomo::AST::Primitive.new(line, :self),
                        as.first,
                        as.last,
                        true
                      )
                    }

    binary_send = line:line binary_send:l sig_sp operator:o sig_sp expression:r
                    { Atomo::AST::BinarySend.new(line, o, l, r) }
                | line:line level3:l sig_sp operator:o sig_sp expression:r
                    { Atomo::AST::BinarySend.new(line, o, l, r) }
                | line:line operator:o sig_sp expression:r
                    { Atomo::AST::BinarySend.new(
                        line,
                        o,
                        Atomo::AST::Primitive.new(line, :self),
                        r
                      )
                    }

           root = expressions:es !. { es }