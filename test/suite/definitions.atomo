describe: "definitions" as: {
  describe: "arguments" as: {
    describe: "splats" as: {
      it: "consumes the rest of the arguments" so: {
        foo(*args) := args
        foo should-be: []
        foo(1) should-be: [1]
        foo(1, 2) should-be: [1, 2]
      }

      it: "starts after required args" so: {
        bar(a, *bs) := [a, bs]
        { bar } should-raise: ArgumentError
        bar(1) should-be: [1, []]
        bar(1, 2) should-be: [1, [2]]
        bar(1, 2, 3) should-be: [1, [2, 3]]
      }

      it: "appears before a block arg" so: {
        baz(a, *bs, &c) := [a, bs, c]
        x = {}
        { baz } should-raise: ArgumentError
        res = baz(1, &x)
        res at(0) should-be: 1
        res at(1) should-be: []
        res at(2) should: { kind-of?(Proc) }

        res = baz(1, 2, 3, &x)
        res at(0) should-be: 1
        res at(1) should-be: [2, 3]
        res at(2) should: { kind-of?(Proc) }
      }
    }

    describe: "default" as: {
      it: "doesn't have to be passed" so: {
        d0(b = 1) := b
        d0 should-be: 1
      }

      it: "may appear after required args" so: {
        d1(a, b = 1) := [a, b]
        d1(0) should-be: [0, 1]
      }

      it: "evaluates an expression as its default" so: {
        d2(a, b = 1 + 1) := [a, b]
        d2(0) should-be: [0, 2]
      }

      it: "evaluates its default with other args in scope" so: {
        d3(a, b = a + 1) := [a, b]
        d3(0) should-be: [0, 1]
      }

      it: "is overrided by an argument" so: {
        d4(a, b = 3) := [a, b]
        d4(0, 1) should-be: [0, 1]
      }

      it: "may appear before a block arg" so: {
        d5(a = 1, &b) := [a, b]
        d5 should-be: [1, nil]
        d5(2) should-be: [2, nil]
      }

      it: "may appear before a splat arg" so: {
        d6(a = 1, *b) := [a, b]
        d6 should-be: [1, []]
        d6(2) should-be: [2, []]
        d6(2, 3) should-be: [2, [3]]
      }
    }
  }
}
