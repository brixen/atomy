module(Atomy::Patterns):
  class(NamedRedirectedInstance < NamedInstance):
    attr-reader(#target, #identifier)

    initialize(@target, @identifier) := nil

    construct(g) := do:
      get(g)
      @target construct(g)
      g push-literal(@identifier)
      g send(#new, 2)

    (== b) :=
      b kind-of?(NamedRedirectedInstance) &&
        @target == b target &&
        @identifier == b identifier

    deconstruct(g, locals = {}) := do:
      @target compile(g)
      g swap
      g push-literal(name)
      g swap
      g send(#instance-variable-set, 2)
      g pop


module(Atomy::AST):
  class(RedirectedInstanceVariable < Node):
    children(#target)
    attributes(#name)
    generate

    bytecode(g) := do:
      pos(g)
      @target compile(g)
      g push-literal(("@" + @name) to-sym)
      g send(#instance-variable-get, 1)

    pattern :=
      Atomy::Patterns::NamedRedirectedInstance new(@target, @name)


macro(~x onto ~(b: Block)):
  names [val]:
    `(do:
        ~val = self
        let-macro(self = '~val
                  Call = to-send tap [p]: p receiver = 'self
                  Binary =
                    if(@private)
                      then: dup tap [p]: p lhs = 'self
                      else: self):
          { with-instance-variables-from(~val) ~b
          } block call-on-instance(~x))


macro(with-instance-variables-from(~x) ~(b: Block)):
  names [val]:
    body = b contents collect [c]:
      c through-quotes([n]: n match: `@@~_ -> true) [n]:
        n match:
          `@~(name: Word) ->
            RedirectedInstanceVariable new(n line, val, name text)

          _ -> n

    `(do: ~val = ~x, ~*body)
