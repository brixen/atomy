dynamic(therie-nesting-level, 0)

module(Therie):
  class(Stats):
    attr-accessor(#passed, #failed)

    initialize := do:
      @passed = 0
      @failed = 0

  { self } indentation :=
    " " * (^therie-nesting-level * 2)

theorize(&as) := do:
  $stats = Therie::Stats new

  as call
  "\n" write

  $stats join:
    [ "total of", failed + passed, "tests"
      "(" + passed to-s ansi-colored(#green), "passed,"
      if(failed == 0)
        then: "0"
        else: failed to-s ansi-colored(#red)
      "failed)"
    ] join(" ") display

    "\n" write

o should(&check) :=
  unless(o join(&check)):
    raise("assertion failed for " + o inspect)

x should-be(y) :=
  unless(x == y):
    raise("expected " + y pretty render + ", got " + x pretty render)

x should-raise(y) :=
  x rescue {
    e ->
      unless(e kind-of?(y)):
        raise("expected exception " + y to-s + ", got: " + e to-s)
  } else:
      raise("#should-raise - no exception raised")

describe(x, &body) := do:
  (Therie indentation + "- " + x to-s) writeln
  let(therie-nesting-level = ^therie-nesting-level + 1):
    body call

it(description, &tests) :=
  { tests call
    (Therie indentation + "✓ " + description)
      ansi-colored(#green) writeln
  } rescue {
    e -> do:
      $stats failed += 1
      (Therie indentation + "✗ " + description)
        ansi-colored(#red) writeln
      (Therie indentation + "  ` " + e class name + ": " + e message)
        ansi-colored(#yellow) writeln
      e backtrace first(5) each (l):
        (Therie indentation + "    " + l ansi-colored(#cyan)) writeln
  } else:
      $stats passed += 1

(s: String) ansi-colored(color) := do:
  codes =
    [ #black
      #red
      #green
      #yellow
      #blue
      #magenta
      #cyan
      #white
    ] zip(Range new(0, 7) to-a)

  hash = Hash new
  codes each ([p, n]):
    hash store(p, n)

  "\e[9" + hash fetch(color) to-s + "m" + s + "\e[0m"
