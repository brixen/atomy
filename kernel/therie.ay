namespace(therie)

dynamic(nesting-level, 0)

class(Stats):
  attr-accessor(#passed, #failed)

  initialize := do:
    @passed = 0
    @failed = 0

indentation :=
  " " * (^nesting-level * 2)

theorize(&as) := do:
  $stats = Stats new

  as call
  "\n" display

  $stats onto:
    f"total of %d tests (%s passed, %s failed)" [
      failed + passed
      passed to-s colored(#green)
      if(failed == 0)
        then: "0"
        else: failed to-s colored(#red)
    ] display

    "\n" display

o should(&check) :=
  unless(o onto(&check)):
    raise(f"assertion failed for %v" [o])

x should-be(y) :=
  unless(x == y):
    raise(f"expected %v, got %v" [x, y])

x should-raise(y) :=
  x rescue {
    e ->
      unless(e kind-of?(y)):
        raise(f"expected exception %s, got: %s" [y, e])
  } else:
      raise("#should-raise - no exception raised")

x should-error(y) :=
  { with-restarts(errored -> nil):
      x call write
      raise("#should-error - no error signaled")
  } bind {
    (e: ExceptionError) ->
      raise(e exception)

    (e: Error) -> do:
      when(e kind-of?(y)):
        restart(#errored)

      raise(f"expected error %s, got: %s" [y, e message])
  }

describe(x, &body) := do:
  f"- %s" [x] indented print
  let(nesting-level = ^nesting-level + 1):
    body call

it(description, &tests) :=
  { tests call
    f"✓ %s" [description] indented colored(#green) print
  } rescue {
    e -> do:
      $stats failed += 1
      f"✗ %s" [description] indented colored(#red) print
      f"  ` %s: %s" [
        e class name
        e message
      ] indented colored(#yellow) print

      e backtrace first(5) each [l]:
        f"    %s" [l colored(#cyan)] indented print
  } else:
      $stats passed += 1

String indented := indentation + self

String colored(color) := do:
  codes =
    [ #black
      #red
      #green
      #yellow
      #blue
      #magenta
      #cyan
      #white
    ] zip((0 ... 7) to-a)

  hash = Hash [codes]

  "\e[9" + hash [color] to-s + "m" + self + "\e[0m"
