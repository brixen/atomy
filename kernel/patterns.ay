use("core")
use("define")
use("cosmetics")
use("control-flow")

Atomy Patterns open:
  -- redefine these in atomy so we can have some base cases
  Pattern <=> x := precision <=> x precision
  Pattern <=> (x: Default) := <=> x pattern
  Pattern <=> (x: Named) := <=> x pattern
  Pattern <=> (x: BlockPass) := <=> x pattern
  Pattern <=> (x: Splat) := <=> x pattern
  Pattern <=> Predicate := -1

  With = Pattern class:
    children(.pattern, .sub-pattern)
    attributes(.expression)
    generate

    construct(g, mod) := do:
      get(g)
      @pattern construct(g, mod)
      @sub-pattern construct(g, mod)
      @expression construct(g, mod)
      g send(.new, 3)
      g dup
      g push-cpath-top
      g find-const(.Atomy)
      g send(.current_module, 0)
      g send(.in_context, 1)
      g pop

    target(g, mod) := @pattern target(g, mod)

    matches(g, mod)? := do:
      mismatch = g new-label
      done = g new-label

      @result = g new-stack-local

      g dup
      @pattern matches(g, mod)?
      g gif(mismatch)

      `{ ~@expression } bytecode(g, mod)
      g send(.block, 0)
      g swap
      g push-scope
      g send(.call-under, 2)
      g set-stack-local(@result)

      @sub-pattern matches(g, mod)?
      g dup
      g git(done)

      mismatch set!
      g pop
      g push-false

      done set!

    matches-self(g, mod)? := do:
      mismatch = g new-label
      done = g new-label

      @result = g new-stack-local

      @pattern matches-self(g, mod)?
      g gif(mismatch)

      mod compile(g, @expression)
      g set-stack-local(@result)

      @sub-pattern matches(g, mod)?
      g dup
      g git(done)

      g pop

      mismatch set!
      g push-false

      done set!

    deconstruct(g, mod, locals = _ Hash new) := do:
      unless(@result): g dup
      @pattern deconstruct(g, mod, locals)

      if(@result)
        then: g push-stack-local(@result)
        else:
          `{ ~@expression } bytecode(g, mod)
          g send(.block, 0)
          g swap
          g push-scope
          g send(.call-under, 2)

      @sub-pattern deconstruct(g, mod, locals)


  And = Pattern class:
    children(.a, .b)
    generate

    target(g, mod) := @a target(g, mod)

    matches(g, mod)? := do:
      mismatch = g new-label
      done = g new-label

      g dup
      @a matches(g, mod)?
      g gif(mismatch)

      @b matches(g, mod)?
      g dup
      g git(done)

      mismatch set!
      g pop
      g push-false

      done set!

    deconstruct(g, mod, locals = _ Hash new) := do:
      g dup
      @a deconstruct(g, mod, locals)
      @b deconstruct(g, mod, locals)


  Or = Pattern class:
    children(.a, .b)
    generate

    target(g, mod) := @a target(g, mod)

    matches(g, mod)? := do:
      matched = g new-label
      done = g new-label

      g dup
      @a matches(g, mod)?
      g git(matched)

      @b matches(g, mod)?
      g dup
      g gif(done)

      matched set!
      g pop
      g push-true

      done set!

    deconstruct(g, mod, locals = _ Hash new) := do:
      b = g new-label
      done = g new-label

      g dup
      g dup
      @a matches(g, mod)?
      g gif(b)

      @a deconstruct(g, mod, locals)
      g pop
      g goto(done)

      b set!
      g pop
      @b deconstruct(g, mod, locals)

      done set!


  Pattern <=> (a: And) := -(a <=> self)
  Pattern <=> (o: Or) := -(o <=> self)

  -- an And precedes x if either precede it
  And <=> x :=
    if(@a <=> x == 1)
      then: 1
      else: @b <=> x
  -- an Or precedes x if neither are preceded by
  Or <=> x :=
    if(@a <=> x == -1)
      then: -1
      else: @b <=> x

  -- TODO
  (a: And) <=> (b: And) :=
    ((a a <=> b a) + (a b <=> b a) + (a a <=> b b) + (a b <=> b b)) <=> 0
  (a: Or) <=> (b: Or) :=
    ((a a <=> b a) + (a b <=> b a) + (a a <=> b b) + (a b <=> b b)) <=> 0


-- base patterns
Atomy Patterns open:
  (Atomy AST Node ? to-word) to-pattern :=
    Named new(Any new
              to-word text)

  Atomy AST Primitive to-pattern :=
    Match new(@value)

  Atomy AST Literal to-pattern :=
    Literal new(@value)

  Atomy AST List to-pattern :=
    List new(@elements collect [e]: e to-pattern)

  Atomy AST Constant to-pattern :=
    Constant new(self)

  Atomy AST ScopedConstant to-pattern :=
    Constant new(self)

  Atomy AST ToplevelConstant to-pattern :=
    Constant new(self)

  Atomy AST Quote to-pattern :=
    Quote new(@expression)

  Atomy AST Block to-pattern :=
    SingletonClass new(body)

  Atomy AST QuasiQuote to-pattern :=
    QuasiQuote new(self)

  `(~x { ~y }) to-pattern :=
    Named new(y to-pattern, x text)

  `(_ ~(y: Atomy AST Constant)) to-pattern :=
    Constant new(Atomy AST ToplevelConstant new(@line, y name))

  `(~x ~(y: Atomy AST Constant)) to-pattern :=
    Constant new(Atomy AST ScopedConstant new(@line, x, y name))

  `(? ~t) to-pattern :=
    Predicate new(Any new, t)

  `(~p ? ~t) to-pattern :=
    Predicate new(p to-pattern, t)

  `@@~(n: ? to-word) to-pattern :=
    NamedClass new(n to-word text)

  `(~x ~(y: ? to-word)) to-pattern :=
    Attribute new(x, y to-word text, [])

  `(~x (~(y: ? to-word))(~*as)) to-pattern :=
    Attribute new(x, y to-word text, as)

  `(~x (~(y: Atomy AST Word))(~*as)?) to-pattern :=
    Attribute new(x, `((~y)?) to-word text, as)

  `(~x (~(y: Atomy AST Word))(~*as)!) to-pattern :=
    Attribute new(x, `((~y)!) to-word text, as)

  `(~a & ~b) to-pattern :=
    And new(a to-pattern, b to-pattern)

  `(~a | ~b) to-pattern :=
    Or new(a to-pattern, b to-pattern)

  `(~x with(~e, ~y)) to-pattern :=
    With new(x to-pattern, y to-pattern, e)

  `(with(~e, ~y)) to-pattern :=
    With new(Any new, y to-pattern, e)

  `(~x [~*as]) to-pattern :=
    Attribute new(x, ."[]", as)

  '_ to-pattern :=
    Any new

  `(~h . ~t) to-pattern :=
    HeadTail new(h to-pattern, t to-pattern)

  `(~p = ~d) to-pattern :=
    Default new(p to-pattern, d)

  `$0 to-pattern :=
    NamedGlobal new("0")

  `$exception to-pattern :=
    NamedGlobal new("!")

  `$path to-pattern :=
    NamedGlobal new(":")

  `$separator to-pattern :=
    NamedGlobal new("/")

  `$~(n: Atomy AST Constant) to-pattern :=
    NamedGlobal new(n name)

  `$~(n: Atomy AST String) to-pattern :=
    NamedGlobal new(n value)

  `$~(n: ? to-word) to-pattern :=
    NamedGlobal new(n to-word text)

  `@~(n: ? to-word) to-pattern :=
    NamedInstance new(n to-word text)

  `&~x to-pattern :=
    BlockPass new(x to-pattern)

  `*~x to-pattern :=
    Splat new(x to-pattern)

  'self to-pattern :=
    Match new(.self)

  'true to-pattern :=
    Match new(.true)

  'false to-pattern :=
    Match new(.false)

  'nil to-pattern :=
    Match new(.nil)

  `.~(x: ? to-word) to-pattern :=
    Literal new(x to-word text)

  `.~(x: Atomy AST Constant) to-pattern :=
    Literal new(x name)

  `.~(x: Atomy AST String) to-pattern :=
    Literal new(x value to-sym)

  Atomy AST Node to-pattern :=
    raise("unknown pattern:\n" + inspect)
