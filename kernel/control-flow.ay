dynamic(labels, Hash new)

macro(if(~x) then ~(y: Block) else ~(z: Block)):
  IfThenElse new(line, x, y body, z body)

macro(otherwise): 'true

macro(return(~y)):
  Return new(line, y)

macro(~x ensuring ~(y: Block)):
  Ensure new(line, x caller, y body)

macro(when(~c) ~(b: Block)):
  When new(line, c, b body)

macro(unless(~c) ~(b: Block)):
  When new(line, `!~c, b body)

macro(super):
  ZSuper new(line)

macro(super ~(blk: Block)):
  Super new(line, [], blk)

macro(super(~*args) ~(blk: Block)):
  Super new(line, args, blk)

macro(super(~*args)):
  Super new(line, args, nil)

macro(break):
  Break new(line, 'nil)

macro(break(~x)):
  Break new(line, x)

macro(next):
  Next new(line, 'nil)

macro(next(~x)):
  Next new(line, x)

evaluate-when(compile, run, load):
  module(Atomy::AST):
    class(Labels < Node):
      children([#tags])
      generate

      bytecode(g) := do:
        pos(g)

        tags = ::Hash new

        labels =
          @tags to-a collect [t]:
            tags [t name] = g new-label

        let(labels = tags):
          labels zip(@tags to-a) each [[l, t]]:
            l set!
            t body compile(g)
            g pop

        g push-nil

    class(LabelBranch < Node):
      children(#body)
      attributes(#name)
      generate

    class(GoTo < Node):
      attributes(#name)
      generate

      bytecode(g) := do:
        pos(g)
        g goto(^labels fetch(@name))

    class(Break < Node):
      children(#value)
      generate

      bytecode(g) := do:
        pos(g)
        @value compile(g)
        g raise-break

    class(Next < Node):
      children(#value)
      generate

      bytecode(g) := do:
        pos(g)
        @value compile(g)
        g ret

macro(labels ~(body: Block)):
  branches = body contents collect [`(~n ~b)]:
    LabelBranch new(n line, b body, n text)

  `(let-macro(go(~'~name) = GoTo new(line, name text)):
      ~(Labels new(line, branches)))

macro(while(~test) ~(body: Block)):
  names [loop, done]:
    `(labels:
        ~loop:
          unless(~test):
            go(~done)

          let-macro(break = 'go(~done),
                    next = 'go(~loop)):
            ~(body body)

          go(~loop)

        ~done {})

macro(until(~test) ~(body: Block)):
  names [loop, done]:
    `(labels:
        ~loop:
          when(~test):
            go(~done)

          let-macro(break = 'go(~done),
                    next = 'go(~loop)):
            ~(body body)

          go(~loop)

        ~done {})

macro(loop ~(body: Block)):
  names [loop, done]:
    `(labels:
        ~loop:
          let-macro(break = 'go(~done),
                    next = 'go(~loop)):
            ~(body body)

          go(~loop)

        ~done {})

for-macro:
  key-from(x) := x
  key-from(x: Atomy::AST::Compose) :=
    if(x right is-a?(Atomy::AST::Block))
      then: x
      else: x right

  pair-from(x) :=
    raise("unknown pair `" + x inspect + "'")

  pair-from(`(~k -> ~v)) :=
    [[k, v]]

  pair-from(p: `(~x { ~*ys })) := do:
    this = [[key-from(x), `(do: ~*ys)]]

    if(x is-a?(Atomy::AST::Compose) && !(x right is-a?(Atomy::AST::Block)))
      then: pair-from(x left) + this
      else: this

  pairs-from(es) :=
    pair-from(e) for(e) in(es) flatten(1)

macro(condition ~(b: Block)):
  pairs-from(b contents) reverse inject('nil) [acc, [x, y]]:
    `(if(~x) then: ~y; else: ~acc)

macro(~val match ~(b: Block)):
  branches = pairs-from(b contents) collect [[x, y]]:
    MatchBranch new(x line, x to-pattern to-node, y)

  Match new(line, val, branches)

macro(~x rescue ~(y: Block)):
  branches = pairs-from(y contents) collect [[p, e]]:
    RescueHandler new(p line, p, e)

  Catch new(line, x caller, branches)

macro(~x rescue ~(y: Block) else ~(z: Block)):
  branches = pairs-from(y contents) collect [[p, e]]:
    RescueHandler new(p line, p, e)

  Catch new(line, x caller, branches, z body)

module(Atomy::AST):
  class(Super < Node):
    children([#arguments], #block?)
    generate

    bytecode(g) := do:
      pos(g)

      block = @block
      splat = nil

      args = 0
      @arguments each [a]:
        e = a prepare
        e match:
          BlockPass:
            block =! e
            break

          Splat:
            splat =! e
            break

          _:
            e bytecode(g)
            args += 1

      when(splat):
        splat compile(g)
        g cast-array

      if(block)
        then: block compile(g)
        else: g push-nil

      g send-super(nil, args, splat)

  class(ZSuper < Node):
    generate

    bytecode(g) := do:
      pos(g)

      g push-block

      if(g state super?)
        then:
          g zsuper(g state super name)
        else:
          g zsuper(nil)
