macro(if(x) then(&y) else(&z)):
  Atomy::AST::IfThenElse new(line, x, y body, z body)

macro(otherwise): 'true

macro(condition(&bs)):
  bs contents reverse inject('nil) [acc, `(~x -> ~y)]:
    `(if(~x) then: ~y; else: ~acc)

macro(while(cond, &body)):
  Atomy::AST::While new(line, cond, body body)

macro(until(cond, &body)):
  Atomy::AST::Until new(line, cond, body body)

macro(return(y)):
  Atomy::AST::Return new(line, y)

macro(x rescue(&y)):
  Atomy::AST::Catch new(line, x caller, y contents)

macro(x rescue(&y) else(&z)):
  Atomy::AST::Catch new(line, x caller, y contents, z body)

macro(x ensuring(&y)):
  Atomy::AST::Ensure new(line, x caller, y body)

macro(when(c, &b)):
  Atomy::AST::When new(line, c, b body)

macro(unless(c, &b)):
  Atomy::AST::When new(line, `!~c, b body)

macro(super):
  Atomy::AST::ZSuper new(line)

macro(super(*args, &blk)):
  Atomy::AST::Super new(line, args, blk)

module(Atomy::AST):
  class(ZSuper < Node):
    generate

    bytecode(g) := do:
      pos(g)

      g push-block

      if(g state super?)
        then:
          g zsuper(g state super name)
        else:
          g zsuper(nil)

  class(Super < Node):
    children([#arguments], #block?)
    generate

    bytecode(g) := do:
      pos(g)

      block = @block
      splat = nil

      args = 0
      @arguments each [a]:
        e = a expand
        e match:
          BlockPass -> do:
            block =! e
            -- break

          Splat -> do:
            splat =! e
            -- break

          _ -> do:
            e bytecode(g)
            args += 1

      when(splat):
        splat compile(g)
        g case-array

      if(block)
        then: block compile(g)
        else: g push-nil

      g send-super(nil, args, splat)
