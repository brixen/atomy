module(Therie) {
  class(Stats) {
    attr_accessor(#passed, #failed)

    initialize :=
      { @passed = 0
        @failed = 0
      } call
  }

  NESTING_LEVEL = 0

  { self } indentation := " " * (NESTING_LEVEL * 2)
}

theorize: as :=
  { $stats = Therie::Stats new

    as call
    puts

    $stats do: {
      [ "total of", failed + passed, "tests"
        "(" + passed to_s ansi-colored: #green, "passed,"
        if: (failed == 0)
          then: { "0" }
          else: { failed to_s ansi-colored: #red }
        "failed)"
      ] join(" ") display

      puts
    }
  } call

o should: (check: Block) :=
  unless(o join: check) {
    raise("assertion failed for " + o inspect)
  }

x should-be: y := x should: { == y }

x should-raise: y :=
  { x call } rescue: { e |
    unless(e kind_of?(y)) {
      raise("expected " + y to_s + ", got: " + e to_s)
    }
  } else: {
    raise("#should-raise: - no exception raised")
  }

describe: x as: body :=
  { puts(Therie indentation + "- " + x to_s)
    Therie::NESTING_LEVEL += 1
    body call
    Therie::NESTING_LEVEL -= 1
  } call

it: description so: tests :=
  { tests call
    puts((Therie indentation + "✓ " + description) ansi-colored: #green)
  } rescue: { e |
    $stats failed += 1
    puts((Therie indentation + "✗ " + description) ansi-colored: #red)
    puts((Therie indentation + "  ` " + e class name + ": " + e message) ansi-colored: #yellow)
    e backtrace each { l |
      puts((Therie indentation + "    " + l) ansi-colored: #cyan)
    }
  } else: {
    $stats passed += 1
  }

(s: String) ansi-colored: color :=
  { codes =
      [ #black
        #red
        #green
        #yellow
        #blue
        #magenta
        #cyan
        #white
      ] zip(Range new(0, 7) to_a)

    hash = Hash new
    codes each { [p, n] |
      hash store(p, n)
    }

    "\e[9" + hash fetch(color) to_s + "m" + s + "\e[0m"
  } call
