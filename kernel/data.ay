macro (&x)
  Atomy::AST::BlockPass new(x line, x)

macro (*x)
  Atomy::AST::Splat new(x line, x)

macro (@(x: Variable))
  Atomy::AST::InstanceVariable new(x line, x name)

macro (@@(x: Variable))
  Atomy::AST::ClassVariable new(x line, x name)

macro ($'exception)
  Atomy::AST::GlobalVariable new(line, "!")

macro ($'path)
  Atomy::AST::GlobalVariable new(line, ":")

macro ($(x: Constant))
  Atomy::AST::GlobalVariable new(x line, x identifier)

macro ($(x: Variable))
  Atomy::AST::GlobalVariable new(x line, x name)

macro (#(x: Constant))
  Atomy::AST::Particle new(x line, x identifier)

macro (#(x: Variable))
  Atomy::AST::Particle new(x line, x name)

macro (a .. b) `(Range new(~a, ~b))
macro (a ... b) `(Range new(~a, ~b, true))

macro (x at(y) put(z))
  Atomy::AST::Send new(
    line
    x
    [y, z]
    "[]="
  )

for-macro quoter(#w) (c): c split

for-macro quoter(#r) (c, fs):
  flags = 0

  when(fs include?("m")):
    flags |= Regexp::MULTILINE

  when(fs include?("i")):
    flags |= Regexp::IGNORECASE

  when(fs include?("x")):
    flags |= Regexp::EXTENDED

  `(Regexp new(~c, ~flags))

for-macro quoter(#raw) (c): c

macro (x for(e) in(c)) `(~c collect (~e): ~x)

macro (x for(e) in(c) if(t)) names (tmp):
  `([] tap (~tmp):
      ~c each (~e):
        when(~t):
          ~tmp << ~x)

macro (data(root, &children)) do:
  cs = children contents map (e):
    e match:
      Atomy::AST::Send -> do:
        name =
          Atomy::AST::Constant new(0, e method-name)

        `(class(~name < ~root):
            attr-accessor(~*(
              e arguments collect (a):
                `#~(a receiver)))

            initialize(~*(e arguments)) := #ok)

      Atomy::AST::Constant ->
        `(class(~e < ~root):)

      Atomy::AST::ScopedConstant ->
        `(class(~e < ~root):)

      Atomy::AST::ToplevelConstant ->
        `(class(~e < ~root):)

      _ -> raise("unknown module name: " + e to-s)

  decls = Atomy::AST::Block new(
    root line
    [`(class(~root):)] + cs
    []
  )

  `(~decls call)

class(Object):
  dynamic-method(#at) (g):
    g total-args = 1
    g required-args = 1
    g local-count = 1

    g push-self
    g push-local(0)
    g send("[]" to-sym, 1)
    g ret
