macro(&x):
  Atomy::AST::BlockPass new(line, x)

macro(*x):
  Atomy::AST::Splat new(line, x)

-- now in boot
--macro(@(x: Variable)):
  --Atomy::AST::InstanceVariable new(x line, x name)

macro(@@(x: Variable)):
  Atomy::AST::ClassVariable new(line, x name)

macro($'0):
  Atomy::AST::GlobalVariable new(line, "0")

macro($(x: String)):
  Atomy::AST::GlobalVariable new(line, x value)

macro($(x: Constant)):
  Atomy::AST::GlobalVariable new(line, x identifier)

macro($(x: Variable)):
  Atomy::AST::GlobalVariable new(line, x name)

macro($'exception):
  Atomy::AST::GlobalVariable new(line, "!")

macro($'path):
  Atomy::AST::GlobalVariable new(line, ":")

macro($'separator):
  Atomy::AST::GlobalVariable new(line, "/")

macro(#(x: Constant)):
  Atomy::AST::Literal new(line, x identifier to-sym)

macro(#(x: Variable)):
  Atomy::AST::Literal new(line, x name to-sym)

macro(#(x: String)):
  Atomy::AST::Literal new(line, x value to-sym)

macro(#(x: Primitive)):
  Atomy::AST::Literal new(line, x value to-s to-sym)

macro(a .. b): `(Range new(~a, ~b))
macro(a ... b): `(Range new(~a, ~b, true))

macro(x for(e) in(c)): `(~c collect [~e]: ~x)

macro(x for(e) in(c) if(t)):
  names [tmp]:
    `([] tap [~tmp]:
        ~c each [~e]:
          when(~t):
            ~tmp << ~x)

module(Enumerable):
  inject-right(i = _undefined, &block) :=
    reverse inject(i) [x, y]: block [y, x]
