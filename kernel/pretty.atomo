-- define our document types structurally via the #data macro
data(Doc) {
  Empty
  Beside(@left, @right, @space?)
  Above(@above, @below, @overlap?)
  Nest(@body, @depth)
  Text(@value)
}


-- trivial emptiness check
Empty empty? := True
Doc empty? := False


-- width of a document
Empty width := 0
Text width := @value size
Beside width :=
  if: @space?
    then: { 1 + @left width + @right width }
    else: { @left width + @right width }
Nest width := (@body width + @depth)
Above width := [@above width, @below width] max


-- height of a document
Empty width := 0
Text height := 1
Beside height := [@left height, @right height] max
Above height :=
  if: (@overlap? && @below kind_of?(Nest) && @below depth > @above width)
    then: { @above height + @below height }
    else: { 1 + @above height + @below height }
Nest height := @body height


-- position one document beside another, separated by a space
-- unless either are empty
(d: Doc) <+> Empty := d
Empty    <+> (d: Doc) := d
(l: Doc) <+> (n: Nest) := (l <+> n body)
(l: Doc) <+> (a: Above) :=
  { first = l <+> a above
    rest = a below nest: (l width + 1)
    Above new(first, rest, a overlap?)
  } call
(l: Doc) <+> (r: Doc) := Beside new(l, r, True)


-- position one document beside another unless either are empty
(d: Doc) <> Empty := d
Empty    <> (d: Doc) := d
(l: Doc) <> (n: Nest) := l <> n body
(l: Doc) <> (a: Above) :=
  { first = l <> a above
    rest = a below nest: l width
    Above new(first, rest, a overlap?)
  } call
(l: Doc) <> (r: Doc) := Beside new(l, r, False)


-- position one document above another, overlapping if possible
(a: Doc) // (b: Doc) := Above new(a, b, True)


-- position one document above another
(a: Doc) /+/ (b: Doc) := Above new(a, b, False)


-- indent the document to a given depth
Nest nest: i := Nest new(@body, @depth + i)
(d: Doc) nest: i := Nest new(d, i)


-- shortcut
a hang: b indented: n := [a, b nest: n]


-- intersperse a delimiter Doc through a list of Docs
-- x punctuate: [p1, ... pn] is [p1 <> x, p2 <> x, ... pn-1 <> x, pn]
Doc punctuate: [] := []
Doc punctuate: [d] := [d]
(delim: Doc) punctuate: (d . ds) :=
  (delim punctuate: ds) unshift(d <> delim)


-- render a document as a string
Text render := @value
Empty render := ""
Beside render :=
  if: @space?
    then: { @left render + " " + @right render }
    else: { @left render + @right render }
Above render :=
  { a = @above render
    b = @below render

    if: (@overlap? && @below kind_of?(Nest) && @below depth > @above width)
      then: {
        b slice!(0, a size)
        a + b
      }
      else: { a + "\n" + b }
  } call
Nest render :=
  { b = @body render
    x = ""
    b each_line { l |
      x << " " * @depth + l
    }
    x
  } call


-- helpers
module(Pretty) {
  -- text
  text: s := Text new(s)
  value: x := Text new(x inspect)

  -- shortcuts
  semi := text: ";"
  comma := text: ","
  colon := text: ":"
  space := text: " "
  equals := text: "="
  lparen := text: "("
  rparen := text: ")"
  lbrack := text: "["
  rbrack := text: "]"
  lbrace := text: "{"
  rbrace := text: "}"

  -- wrapping documents
  parens: d := lparen <> d <> rparen
  brackets: d := lbrack <> d <> rbrack
  braces: d := lbrace <> d <> rbrace
  quotes: d := text: "'" <> d <> text: "'"
  double-quotes: d := text: "\"" <> d <> text: "\""

  -- combining documents
  empty := Empty new
  hcat: ds := ds inject(empty) { a b | a <> b }
  hsep: ds := ds inject(empty) { a b | a <+> b }
  vcat: ds := ds inject(empty) { a b | a // b }
}

Doc extend(Pretty)

doc(&body) := with: Pretty do: body

(o: Object) pretty := Doc text: inspect

module(Atomo::AST) {
  { self } comma-delim: es := doc {
    hsep: (comma punctuate: es map { e | e pretty })
  }

  { self } semi-delim: es := doc {
    hsep: (semi punctuate: es map { e | e pretty })
  }

  Assign pretty := doc { @lhs pretty <+> text: "=" <+> @body pretty }

  BinarySend pretty := doc {
    @lhs pretty <+> text: @operator <+> @rhs pretty
  }

  Block pretty := doc {
    lbrace <+> Atomo::AST semi-delim: @body expressions <+> rbrace
  }

  BlockPass pretty := doc { text: "&" <> @body pretty }

  Class pretty := doc {
    sub =
      if: (@superclass kind_of?(Primitive) && @superclass value == #nil)
        then: { empty }
        else: { text: "<" <+> @superclass pretty }

    name =
      @name match: {
        Rubinius::AST::ClassName -> text: @name name to_s
        _ -> @name pretty
      }

    body = lbrace <+> Atomo::AST semi-delim: @body body expressions <+> rbrace

    text: "class" <> text: "(" <> name <+> sub <> text: ")" <+> body
  }

  ClassVariable pretty := doc { text: @name to_s }

  Constant pretty := doc { text: @name to_s }

  Define pretty := doc { @lhs pretty <+> text: ":=" <+> @body pretty }

  ForMacro pretty := doc { text: "for-macro" <+> @body pretty }

  GlobalVariable pretty := doc { text: @name to_s }

  InstanceVariable pretty := doc { text: @name to_s }

  KeywordSend pretty := doc {
    pairs = @names zip(@arguments) collect { p |
      text: (p first + ":") <+> p last pretty
    }

    if: (@receiver kind_of?(Primitive) && @receiver value == #self)
      then: { hsep: pairs }
      else: {
        @receiver pretty <+> hsep: pairs
      }
  }

  List pretty := doc { brackets: (Atomo::AST comma-delim: @elements) }

  Macro pretty := doc {
    text: "macro" <+> parens: @pattern pretty <+> @body pretty
  }

  Particle pretty := doc { text: "#" <> text: @name }

  Primitive pretty :=
    @value match: {
      #self -> text: "self"
      #true -> text: "True"
      #false -> text: "False"
      #nil -> text: "nil"
      x -> x pretty
    }

  QuasiQuote pretty := doc { text: "`" <> @expression pretty }

  Quote pretty := doc { text: "'" <> @expression pretty }

  ScopedConstant pretty := doc {
    @parent pretty <> text: "::" <> text: @name to_s
  }

  String pretty := @value pretty

  ToplevelConstant pretty := doc { text: "::" <> text: @name to_s }

  UnarySend pretty := doc {
    block = if: @block then: { @block pretty } else: { empty }

    args =
      if: @arguments empty?
        then: { empty }
        else: { parens: (Atomo::AST comma-delim: @arguments) }

    if: (@receiver kind_of?(Primitive) && @receiver value == #self)
      then: { text: @method_name <> args <+> block }
      else: {
        @receiver pretty <+> text: @method_name <> args <+> block
      }
  }

  Unquote pretty := doc { text: "~" <> @expression pretty }

  Variable pretty := doc { text: @name }
}
