macro (x = y)
  Atomo::AST::Assign new(x line, x, y)

macro (x match: (b: Block))
  { n = Atomo::AST::Match new(x line, x, b)
    `({ ~n } call)
  } call

macro ((x: BinarySend) := y)
  Atomo::AST::Define new(
    x line
    x operator
    x lhs
    [x rhs]
    y
  )

macro ((x: Variable) := y)
  Atomo::AST::Define new(
    x line
    x name
    'self
    []
    y
  )

macro (x := y)
  Atomo::AST::Define new(
    x line
    x method_name
    x receiver
    x arguments
    y
  )

macro (if: cond then: true else: false)
  Atomo::AST::IfThenElse new(cond line, cond, true, false)

macro (class(pair: BinarySend, &body))
  if: (pair lhs == 'self)
    then: { Atomo::AST::Metaclass new(pair line, pair rhs, body body) }
    else: { Atomo::AST::Class new(pair line, pair lhs, pair rhs, body body) }

macro (class(name, &body))
  Atomo::AST::Class new(name line, name, nil, body body)

macro (module(name, &body))
  Atomo::AST::Module new(name line, name, body body)

macro (x rescue: y)
  Atomo::AST::Catch new(x line, x body, `(~y call($!)))

macro (x rescue: y else: z)
  Atomo::AST::Catch new(x line, x body, `(~y call($!)), z body)

macro (... x) Atomo::AST::Splat new(x line, x)

macro (data(root, &children))
  { cs = children body expressions map { e |
      e match: {
        Atomo::AST::UnarySend ->
          { init =
              Atomo::AST::UnarySend new(
                0
                Atomo::AST::Primitive new(0, #self)
                "initialize"
                e arguments
              )

            accessors =
              Atomo::AST::UnarySend new(
                0
                Atomo::AST::Primitive new(0, #self)
                "attr_accessor"
                e arguments map { a |
                  name = a name to_s
                  name slice!(0)
                  Atomo::AST::Particle new(0, name)
                }
              )

            name =
              Atomo::AST::Constant new(0, e method_name)

            `(class(~name < ~root) {
                ~accessors
                ~init := #ok
              })
          } call

        Atomo::AST::Constant ->
          `(class(~e < ~root) {})

        _ -> raise("don't know what to do with " + e to_s)
      }
    }

    decls = Atomo::AST::Block new(
      root line
      [`(class(~root) {})] + cs
      []
    )

    `(~decls call)
  } call

Block = Rubinius::BlockEnvironment

x join: (b: Block) := b call_on_instance(x)

x do: (b: Block) :=
  { b call_on_instance(x)
    x
  } call
