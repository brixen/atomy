macro (x = y)
  Atomo::AST::Assign new(x line, x, y)

macro (x match: (b: Block))
  { n = Atomo::AST::Match new(x line, x, b)
    `({ ~n } call)
  } call

macro ((x: BinarySend) := y)
  Atomo::AST::Define new(
    x line
    x operator
    x lhs
    [x rhs]
    y
  )

macro ((x: Variable) := y)
  Atomo::AST::Define new(
    x line
    x name
    'self
    []
    y
  )

macro (x := y)
  Atomo::AST::Define new(
    x line
    x method_name
    x receiver
    x arguments
    y
  )

macro (if: cond then: true else: false)
  Atomo::AST::IfThenElse new(cond line, cond, true, false)

macro (while: cond do: body)
  Atomo::AST::While new(cond line, cond, body body)

macro (x return(y))
  Atomo::AST::Return new(x line, y)

macro (class(pair: BinarySend, &body))
  if: (pair lhs == 'self)
    then: { Atomo::AST::Metaclass new(pair line, pair rhs, body body) }
    else: { Atomo::AST::Class new(pair line, pair lhs, pair rhs, body body) }

macro (class(name, &body))
  Atomo::AST::Class new(name line, name, nil, body body)

macro (module(name, &body))
  Atomo::AST::Module new(name line, name, body body)

macro (x rescue: y)
  Atomo::AST::Catch new(x line, x body, `(~y call($!)))

macro (x rescue: y else: z)
  Atomo::AST::Catch new(x line, x body, `(~y call($!)), z body)

macro (x ensuring: y)
  Atomo::AST::Ensure new(x line, `(~x call), `(~y call))

macro (... x) Atomo::AST::Splat new(x line, x)

macro (data(root, &children))
  { cs = children body expressions map { e |
      e match: {
        Atomo::AST::UnarySend ->
          { init =
              Atomo::AST::UnarySend new(
                0
                Atomo::AST::Primitive new(0, #self)
                "initialize"
                e arguments
              )

            accessors =
              Atomo::AST::UnarySend new(
                0
                Atomo::AST::Primitive new(0, #self)
                "attr_accessor"
                e arguments map { a |
                  name = a name to_s
                  name slice!(0)
                  Atomo::AST::Particle new(0, name)
                }
              )

            name =
              Atomo::AST::Constant new(0, e method_name)

            `(class(~name < ~root) {
                ~accessors
                ~init := #ok
              })
          } call

        Atomo::AST::Constant ->
          `(class(~e < ~root) {})

        Atomo::AST::ScopedConstant ->
          `(class(~e < ~root) {})

        Atomo::AST::ToplevelConstant ->
          `(class(~e < ~root) {})

        _ -> raise("unknown module name: " + e to_s)
      }
    }

    decls = Atomo::AST::Block new(
      root line
      [`(class(~root) {})] + cs
      []
    )

    `(~decls call)
  } call

Block = Rubinius::BlockEnvironment

x join: (b: Block) := b call_on_instance(x)

x do: (b: Block) :=
  { b call_on_instance(x)
    x
  } call

class(And < Atomo::AST::Node) {
  initialize(@line, @a, @b) := #ok

  bytecode(g) :=
    { pos(g)
      done = g new_label
      no = g new_label

      @a bytecode(g)
      g gif(no)

      @b bytecode(g)
      g goto(done)

      no set!
      g push_false

      done set!
    } call

  -- TODO: recursively
}

class(Or < Atomo::AST::Node) {
  initialize(@line, @a, @b) := #ok

  bytecode(g) :=
    { pos(g)
      done = g new_label
      yes = g new_label

      @a bytecode(g)
      g git(yes)

      @b bytecode(g)
      g goto(done)

      yes set!
      g push_true

      done set!
    } call

  -- TODO: recursively
}

macro (a && b) And new(a line, a, b)
macro (a || b) Or new(a line, a, b)

(o: Object) pretty := Doc text: inspect

module(Atomo::AST) {
  BinarySend pretty := doc {
    @lhs pretty <+> text: @operator <+> @rhs pretty
  }

  Primitive pretty := @value pretty

  Block pretty := doc {
    body = @body expressions map { e | e pretty }
    lbrace <+> (hsep: (semi punctuate: body)) <+> rbrace
  }

  Variable pretty := doc { text: @name }
}
