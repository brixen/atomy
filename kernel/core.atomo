macro (x = y)
  Atomo::AST::Assign new(x line, x, y)

macro (x set!: y)
  Atomo::AST::Set new(x line, x, y)

macro (x match: (b: Block))
  { n = Atomo::AST::Match new(x line, x, b)
    `({ ~n } call)
  } call

macro ((x: BinarySend) := y)
  Atomo::AST::Define new(
    x line
    x operator
    x lhs
    [x rhs]
    y
  )

macro ((x: Variable) := y)
  Atomo::AST::Define new(
    x line
    x name
    'self
    []
    y
  )

macro (x := y)
  Atomo::AST::Define new(
    x line
    x method_name
    x receiver
    x arguments
    y
  )

macro (if: cond then: true else: false)
  Atomo::AST::IfThenElse new(cond line, cond, true, false)

macro (while: cond do: body)
  Atomo::AST::While new(cond line, cond, `(~body call))

macro (x return(y))
  Atomo::AST::Return new(x line, y)

macro (class(pair: BinarySend, &body))
  if: (pair lhs == 'self)
    then: { Atomo::AST::Metaclass new(pair line, pair rhs, body body) }
    else: { Atomo::AST::Class new(pair line, pair lhs, pair rhs, body body) }

macro (class(name, &body))
  Atomo::AST::Class new(name line, name, nil, body body)

macro (module(name, &body))
  Atomo::AST::Module new(name line, name, body body)

macro (x rescue: y)
  Atomo::AST::Catch new(x line, `(~x call), `(~y call($!)))

macro (x rescue: y else: z)
  Atomo::AST::Catch new(x line, `(~x call), `(~y call($!)), z body)

macro (x ensuring: y)
  Atomo::AST::Ensure new(x line, `(~x call), `(~y call))

macro (... x) Atomo::AST::Splat new(x line, x)

macro (data(root, &children))
  { cs = children body expressions map { e |
      e match: {
        Atomo::AST::UnarySend ->
          { init =
              Atomo::AST::UnarySend new(
                0
                Atomo::AST::Primitive new(0, #self)
                "initialize"
                e arguments
              )

            accessors =
              Atomo::AST::UnarySend new(
                0
                Atomo::AST::Primitive new(0, #self)
                "attr_accessor"
                e arguments map { a |
                  name = a name to_s
                  name slice!(0)
                  Atomo::AST::Particle new(0, name)
                }
              )

            name =
              Atomo::AST::Constant new(0, e method_name)

            `(class(~name < ~root) {
                ~accessors
                ~init := #ok
              })
          } call

        Atomo::AST::Constant ->
          `(class(~e < ~root) {})

        Atomo::AST::ScopedConstant ->
          `(class(~e < ~root) {})

        Atomo::AST::ToplevelConstant ->
          `(class(~e < ~root) {})

        _ -> raise("unknown module name: " + e to_s)
      }
    }

    decls = Atomo::AST::Block new(
      root line
      [`(class(~root) {})] + cs
      []
    )

    `(~decls call)
  } call

Block = Rubinius::BlockEnvironment

x join: (b: Block) := b call_on_instance(x)

x do: (b: Block) :=
  { b call_on_instance(x)
    x
  } call

class(And < Atomo::AST::Node) {
  initialize(@line, @a, @b) := #ok

  bytecode(g) :=
    { pos(g)
      done = g new_label
      no = g new_label

      @a bytecode(g)
      g gif(no)

      @b bytecode(g)
      g goto(done)

      no set!
      g push_false

      done set!
    } call

  -- TODO: stop should default to nil
  recursively(stop, &f) :=
    if: (stop call(self))
      then: { f call(self) }
      else: {
        And new(
          @line
          @a recursively(stop, &f)
          @b recursively(stop, &f)
        )
      }
}

class(Or < Atomo::AST::Node) {
  initialize(@line, @a, @b) := #ok

  bytecode(g) :=
    { pos(g)
      done = g new_label
      yes = g new_label

      @a bytecode(g)
      g git(yes)

      @b bytecode(g)
      g goto(done)

      yes set!
      g push_true

      done set!
    } call

  -- TODO: stop should default to nil
  recursively(stop, &f) :=
    if: (stop call(self))
      then: { f call(self) }
      else: {
        Or new(
          @line
          @a recursively(stop, &f)
          @b recursively(stop, &f)
        )
      }
}

macro (a && b) And new(a line, a, b)
macro (a || b) Or new(a line, a, b)

(o: Object) pretty := Doc text: inspect

module(Atomo::AST) {
  { self } comma-delim: es := doc {
    hsep: (comma punctuate: es map { e | e pretty })
  }

  { self } semi-delim: es := doc {
    hsep: (semi punctuate: es map { e | e pretty })
  }

  BinarySend pretty := doc {
    @lhs pretty <+> text: @operator <+> @rhs pretty
  }

  Block pretty := doc {
    lbrace <+> Atomo::AST semi-delim: @body expressions <+> rbrace
  }

  BlockPass pretty := doc { text: "&" <> @body pretty }

  ClassVariable pretty := doc { text: "@@" <> text: @name }

  Constant pretty := doc { text: @name }

  ForMacro pretty := doc { text: "for-macro" <+> @body pretty }

  GlobalVariable pretty := doc { text: "$" <> text: @name }

  InstanceVariable pretty := doc { text: "@" <> text: @name }

  -- TODO: KeywordSend

  List pretty := doc { brackets: (Atomo::AST comma-delim: @elements) }

  Macro pretty := doc {
    text: "macro" <+> parens: @pattern pretty <+> @body pretty
  }

  Particle pretty := doc { text: "#" <> text: @name }

  Primitive pretty := @value pretty

  QuasiQuote pretty := doc { text: "`" <> @expression pretty }

  Quote pretty := doc { text: "'" <> @expression pretty }

  ScopedConstant pretty := doc {
    @parent pretty <> text: "::" <> text: @name
  }

  String pretty := @value pretty

  ToplevelConstant pretty := doc { text: "::" <> text: @name }

  UnarySend pretty := doc {
    block = if: @block then: { @block pretty } else: { empty }

    args =
      if: @arguments empty?
        then: { empty }
        else: { parens: (Atomo::AST comma-delim: @arguments) }

    if: @private
      then: { text: @method_name <> args <+> block }
      else: {
        @receiver pretty <+> text: @method_name <> args <+> block
      }
  }

  Unquote pretty := doc { text: "~" <> @expression pretty }

  Variable pretty := doc { text: @name }
}
