-- a macro so we can actually, you know, send messages
macro(x ~Variable): set-method-name

macro(@x): InstanceVariable new(line, x name)

macro(x = y): Assign new(line, x, y)

-- foo { bar }
macro(Variable ~Block):
  Send new(
    line
    @receiver
    'self
    []
    @message
  )

-- [x, y] { x + y }
macro(List ~Block):
  @message arguments = @receiver elements
  @message

-- x foo { bar }
macro(Send ~Block):
  @receiver block = @message
  @receiver

-- collect [x] { x + 1 }
macro(x [~*ys] ~(z: Block)):
  z arguments = ys
  Send new(
    line
    x
    'self
    []
    z
  )

-- [1, 2, 3] collect [x] { x + 1 }
macro((x: Send) [~*ys] ~(z: Block)):
  z arguments = ys
  x block = z
  x

-- foo [bar, ...]
macro(x [*ys]):
  @method-name = "[]"
  @arguments = ys + @arguments
  self

-- Foo(...)
macro(x ~Constant):
  @method-name = @message identifier
  self

-- Bar::Foo(...)
macro(x ~ScopedConstant):
  @method-name = @message identifier
  @receiver = @message parent
  self

-- ::Foo(...)
-- note: this isn't valid Ruby
macro(x ~ToplevelConstant):
  @method-name = @message identifier
  self

macro(_LINE): line
macro(_FILE): File new(line)

macro(import(name)): `(Atomy import(~name, "load" to-sym))

"operators define cosmetics data comparison dynamic control-flow namespaces
patterns precision data-delta" split each [k]:
  puts("loading " + k)
  import(File expand-path("../", _FILE) + "/" + k)

--"operators define cosmetics data comparison dynamic control-flow namespaces
--patterns precision data-delta documentation particles hashes node block
--doc pretty errors format concurrency io condition therie repl" split each [k]:
  --puts("loading " + k)
  --import(File expand-path("../", _FILE) + "/" + k)
