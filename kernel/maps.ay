for-macro:
  key-name(x: Atomy::AST::Compose) := key-name(x right)
  key-name(x: Atomy::AST::Variable) := x name


syntax(#(l: List)):
  pairs = pairs-from(l elements)
  keys = pairs collect [[k, _]]: `#~key-name(k)
  values = pairs collect [[_, v]]: v
  Atomy::AST::Map new(line, keys, values)


class(Atomy::AST::Map < Atomy::AST::Node):
  children([#keys], [#values])
  generate

  bytecode(g) := do:
    pos(g)

    g push-cpath-top
    g find-const(#Atomy)
    g find-const(#Map)

    g push-cpath-top
    g find-const(#Hash)
    g push-int(@keys size)
    g send(#new-from-literal, 1)

    @keys each-with-index [n, i]:
      g dup
      n compile(g)
      @values [i] compile(g)
      g send("[]=" to-sym, 2)
      g pop

    g send(#create, 1)

class(Atomy::Map < Hamster::Hash):
  class(<< self):
    create(pairs = ::Hash new, &blk) := do:
      base =
        if(blk)
          then: Map new(&blk)
          else: Atomy::EmptyMap

      pairs reduce(base) [hash, pair]: hash put(pair first, pair last)

Atomy::EmptyMap = Atomy::Map new
