macro (data(root, &children)) do:
  cs = children contents map (e):
    e match:
      Atomy::AST::Send -> do:
        name =
          Atomy::AST::Constant new(0, e method-name)

        pat = name

        tmps = names(e arguments size) collect (t):
          Atomy::AST::Unquote new(0, t)

        e arguments zip(tmps) ([a, t]):
          pat =! `(~pat & with(~a, ~t))

        pat = pat expand

        cons = Atomy::AST::Send new(
          0
          'self
          tmps
          name identifier
          nil
          true
        )

        pat-def =
          `(~(Atomy::AST::QuasiQuote new(0, cons)) to-pattern :=
              ~(Atomy::AST::QuasiQuote new(0, pat)) to-pattern)

        define =
          `({ class(~name < ~root):
                attr-accessor(~*(
                  e arguments collect (a):
                    `#~(a receiver)))

                initialize(~*(e arguments)) := #ok

              ~pat-def
            }) body

        if(e block)
          then:
            `({ ~define

                data(~name):
                  ~*(e block contents)
              }) body
          else:
            define

      Atomy::AST::Constant ->
        `(class(~e < ~root):)

      Atomy::AST::ScopedConstant ->
        `(class(~e < ~root):)

      Atomy::AST::ToplevelConstant ->
        `(class(~e < ~root):)

      _ -> raise("unknown module name: " + e to-s)

  `{ class(~root):;, ~*cs } body


for-macro quoter(#w) (c): c split

for-macro quoter(#r) (c, fs):
  flags = 0

  when(fs include?("m")):
    flags |= Regexp::MULTILINE

  when(fs include?("i")):
    flags |= Regexp::IGNORECASE

  when(fs include?("x")):
    flags |= Regexp::EXTENDED

  `(Regexp new(~c, ~flags))

for-macro quoter(#raw) (c): c

for-macro
  class(<< self):
    wildcard('_) := '_undefined
    wildcard(x) := x

macro (_undefined)
  Atomy::AST::Undefined new(line)

macro (#(x: Send)) do:
  args =
    if(x block)
      then: x block contents collect (c): wildcard(c)
      else: []

  `([ ~(if(x private)
          then: '_undefined
          else: wildcard(x receiver))
      ~(Atomy::AST::Particle new(0, x method-name))
      ~*(args)
    ])

macro (#(x: BinarySend))
  `([ ~(if(x private)
          then: '_undefined
          else: wildcard(x lhs))
      ~(Atomy::AST::Particle new(0, x operator))
      ~(wildcard(x rhs))
    ])

Array rest := drop(1)

Array call(*args) := do:
  args each (a):
    idx = find-index (x): x equal?(_undefined)
    when(idx):
      self at(idx) put(a)

  first send(*rest)
