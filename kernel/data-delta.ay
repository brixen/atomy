namespace(atomy)

macro(data(root, &children)):
  cs = children contents map [e]:
    e match:
      Atomy::AST::Send -> do:
        name =
          Atomy::AST::Constant new(0, e method-name)

        pat = name

        tmps = names(e arguments size) collect [t]:
          Atomy::AST::Unquote new(0, t)

        e arguments zip(tmps) [[a, t]]:
          pat =! `(~pat & with(~a, ~t))

        cons = `(~(name)(~*tmps))

        pat-def =
          `(~(Atomy::AST::QuasiQuote new(0, cons)) pattern :=
              ~(Atomy::AST::QuasiQuote new(0, pat)) pattern)

        define =
          `(export:
              class(~name < ~root):
                attr-accessor(~*(
                  e arguments collect [a]:
                    `#~(a receiver)))

                initialize(~*(e arguments)) := nil

              ~pat-def)

        if(e block)
          then:
            `(do:
                ~define

                data(~name):
                  ~*(e block contents))
          else:
            define

      Atomy::AST::Constant ->
        `(class(~e < ~root):)

      Atomy::AST::ScopedConstant ->
        `(class(~e < ~root):)

      Atomy::AST::ToplevelConstant ->
        `(class(~e < ~root):)

      _ -> raise("unknown module name: " + e to-s)

  `(do: class(~root):;, ~*cs)


macro(macro-quoter(n, &x)):
  `(evaluate-when(compile, load):
      Atomy::Macro::Environment quoter(#~n, &~x))

macro-quoter(w) [c]: c split

macro-quoter(r) [c, fs]:
  flags = 0

  when(fs include?("m")):
    flags |= Regexp::MULTILINE

  when(fs include?("i")):
    flags |= Regexp::IGNORECASE

  when(fs include?("x")):
    flags |= Regexp::EXTENDED

  when(fs include?("u")):
    flags |= Regexp::KCODE_UTF8

  `(Regexp new(~c, ~flags))

macro-quoter(raw) [c]: c

macro(_undefined):
  Atomy::AST::Undefined new(line)

macro($(x: Primitive ? @value is-a?(::Integer) && @value > 0)):
  Atomy::AST::NthRef new(line, x value)

export:
  module(Atomy::AST):
    class(Undefined < Node):
      generate

      bytecode(g) := do:
        pos(g)
        g push-undef

      pattern := Atomy::Patterns::Any new

    class(NthRef < Rubinius::AST::NthRef):
      include(NodeLike)
      extend(SentientNode)
      attributes(#which)
      generate
