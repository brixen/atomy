namespace(atomy)

macro(data(root, &children)):
  cs = children contents map [e]:
    e match:
      Atomy::AST::Send -> do:
        name =
          Atomy::AST::Constant new(0, e method-name)

        pat = name

        tmps = names(e arguments size) collect [t]:
          Atomy::AST::Unquote new(0, t)

        e arguments zip(tmps) [[a, t]]:
          pat =! `(~pat with(~a, ~t))

        cons = `(~(name)(~*tmps))

        pat-def =
          `(~(Atomy::AST::QuasiQuote new(0, cons)) pattern :=
              ~(Atomy::AST::QuasiQuote new(0, pat)) pattern)

        define =
          `(export:
              class(~name < ~root):
                attr-accessor $:
                  ~*(e arguments collect [a]:
                      `#~(a receiver))

                initialize(~*(e arguments)) := nil

              ~pat-def)

        if(e block)
          then:
            `(do:
                ~define

                data(~name):
                  ~*(e block contents))
          else:
            define

      Atomy::AST::Constant ->
        `(class(~e < ~root):)

      Atomy::AST::ScopedConstant ->
        `(class(~e < ~root):)

      Atomy::AST::ToplevelConstant ->
        `(class(~e < ~root):)

      _ -> raise("unknown module name: " + e to-s)

  `(do: class(~root) {}, ~*cs, nil)


macro(macro-quoter(n, &x)):
  `(evaluate-when(compile, load):
      Atomy::Macro::Environment quoter(#~n, &~x))

for-macro:
  intp-segments(s) :=
    s split(Regexp new("(?<!\\\\)#\\{"), 2) match:
      [] -> ['""]

      [x] -> [x to-node]

      [pre, chunk] -> do:
        p = Atomy::Parser new(chunk)

        unless(p parse("interpolated")):
          p raise-error

        segments = [pre to-node, `(~(p result) to-s)]

        rest = p string [p pos .. -1]

        rest match:
          nil -> segments
          "" -> segments
          _ -> segments + intp-segments(rest)

  interpolated(x) :=
    Atomy::AST::Interpolation new(0, intp-segments(x))

  code-from("}" . rest, 0 = 0) := ["", rest join]
  code-from("}" . rest, depth = 0) := do:
    [c, r] = code-from(rest, depth - 1)
    ["{" + c, r]
  code-from("{" . rest, depth = 0) := do:
    [c, r] = code-from(rest, depth + 1)
    ["{" + c, r]
  code-from(x . rest, depth = 0) := do:
    [xs, r] = code-from(rest, depth + 1)
    [x + xs, r]

macro-quoter(w) [_, _, v]: v split

macro-quoter(r) [r, fs]:
  flags = 0

  when(fs include?("m")):
    flags |= Regexp::MULTILINE

  when(fs include?("i")):
    flags |= Regexp::IGNORECASE

  when(fs include?("x")):
    flags |= Regexp::EXTENDED

  when(fs include?("u")):
    flags |= Regexp::KCODE_UTF8

  `(::Regexp new(~interpolated(r), ~flags))

macro-quoter(raw) [r]: r

macro-quoter(i) [_, _, v]: interpolated(v)

macro(_undefined):
  Atomy::AST::Undefined new(line)

macro($(x: Primitive ? @value is-a?(::Integer) && @value > 0)):
  Atomy::AST::NthRef new(line, x value)

export:
  module(Atomy::AST):
    class(Undefined < Node):
      generate

      bytecode(g) := do:
        pos(g)
        g push-undef

      pattern := Atomy::Patterns::Any new

    class(NthRef < Rubinius::AST::NthRef):
      include(NodeLike)
      extend(SentientNode)
      attributes(#which)
      generate

    class(Interpolation < Node):
      children([#segments])
      generate

      bytecode(g) := do:
        pos(g)

        @segments each [s]:
          s bytecode(g)

        g string-build(@segments size)

