namespace(atomy/pretty)
use(atomy)
Array all-pretty := self collect [x]: x atomy/pretty

comma-delim(ds) :=
  hsep(comma punctuate(ds))


export-to(atomy):
  (o: Object) pretty := Doc text(inspect)

  Array pretty :=
    doc: brackets(comma-delim(self all-pretty))
    operator? = self message to-s !~ r"^[a-z_]"

  Particle pretty := doc:
    wildcard = [c]:
      if(c equal?(_undefined))
        then: '_
        else: c


    args = self arguments collect(&#(wildcard [_]))

    msg+args =
      if(operator?)
        then:
          text(self message to-s) <+> args first pretty
        else:
          text(self message to-s) <>
            parens(comma-delim(args all-pretty))

    partial =
      if(self receiver equal?(_undefined))
        then:
          if(operator?)
            then: parens(msg+args)
            else: msg+args
        else: parens(self receiver pretty <+> msg+args)

    text("#") <> partial

  Symbol pretty := do:
    s = to-s
    if(s =~ r(u)"^[\p{Ll}_]([\p{L}\d\p{S}!@#%&*\-\\:.\/\?])*$")
      then: Doc text("#" + s)
      else: Doc text("#") <> s pretty

  Hash pretty := doc:
    text("#") <>
      brackets(
        comma-delim(
          self to-a collect [[k, v]]:
            k pretty <+> text("->") <+> v pretty))

  module(Atomy::AST):
    Assign pretty := doc: @lhs pretty <+> text("=") <+> @rhs pretty

    BinarySend pretty := doc:
      parens(@lhs pretty <+> text(@operator) <+> @rhs pretty)
      args <> colon <+> comma-delim(@contents all-pretty) <> semi

    Block pretty := doc:
      args =
        if(@arguments empty?)
          then: empty
          else: parens(comma-delim(@arguments all-pretty))


    BlockPass pretty := doc: text("&") <> @body pretty

    Class pretty := doc:
      sub =
        if(@superclass kind-of?(Primitive) && @superclass value == #nil)
          then: empty
          else: text("<") <+> @superclass pretty
      body = lbrace <+> semi-delim(@body) expressions <+> rbrace

      name =
        @name match:
          Rubinius::AST::ClassName -> text(@name) name to-s
          _ -> @name pretty


      text("class") <> text("(") <> name <+> sub <> text(")") <+> body

    ClassVariable pretty := doc: text(name to-s)

    Constant pretty := doc: text(@identifier)

    Define pretty := doc: @lhs pretty <+> text(":=") <+> @body pretty

    GlobalVariable pretty := doc: text(name to-s)

    InstanceVariable pretty := doc: text(name to-s)

    List pretty := doc: brackets(comma-delim(@elements all-pretty))

    Macro pretty := doc:
      text("macro") <+> parens(@pattern pretty) <+> @body pretty

    Particle pretty := doc: text("#") <> text(@name)

    Primitive pretty := doc:
      @value match:
        #self -> text("self")
        #true -> text("true")
        #false -> text("false")
        #nil -> text("nil")
        x -> x pretty

    QuasiQuote pretty := doc: text("`") <> parens(@expression pretty)

    Quote pretty := doc: text("'") <> parens(@expression pretty)

    ScopedConstant pretty := doc:
      @parent pretty <> text("::") <> text(name to-s)

    Send pretty := doc:
      block = if(@block) then: @block pretty; else: empty

      args =
        if(@arguments empty?)
          then: empty
          else: parens(comma-delim(@arguments all-pretty))

      if(@receiver kind-of?(Primitive) && @receiver value == #self)
        then: text(@method-name) <> args <+> block
        else:
          @receiver pretty <+> text(@method-name) <> args <+> block

    Splice pretty := doc: text("~*") <> parens(@expression pretty)

    String pretty := @value pretty

    ToplevelConstant pretty := doc: text("::") <> text(name to-s)

    Unary pretty := doc: text(@operator) <> parens(@receiver pretty)

    Unquote pretty := doc: text("~") <> parens(@expression pretty)

    Variable pretty := doc: text(@name)

    InlinedBody pretty := doc:
      parens(hsep(comma punctuate(@expressions collect [e]: e pretty)))

    Or pretty := `(~@a || ~@b) pretty

    And pretty := `(~@a && ~@b) pretty

    Ensure pretty := doc:
      @body pretty <+> text("ensuring:") <+> @ensure pretty
