use("core")
use("define")
use("control-flow")
use("cosmetics")
use("particles")
use("comparison")
use("range")
use("regexp")
use("array")
use("undefined")

use("dynamic")
use("doc")

io = use("io")

Printing = dynamic([])
Multiline = dynamic(false)
Context = dynamic(.top)
Colored = dynamic(false)

ident(n) := text(n [0, 1] + n [1 .. -1] tr("_", "-") gsub("_ns_", "/"))

pretty-sequence([]) := []
pretty-sequence([x]) := [from(.top): x pretty]
pretty-sequence(x . xs) := [from(.list) { x pretty }] + pretty-sequence(xs)

tree(xs) := align(fill-sep(comma punctuate(xs)))

_ unamb := pretty

from(*where) &y :=
  let(Context = where flatten):
    y call

from(*where)? :=
  [^Context, where] match:
    [(a: Array), (b: Array)] ->
      a any? [x]: b include(x)?
    [(a: Array), b] ->
      a include(b)?
    [a, (b: Array)] ->
      b include(a)?
    [a, b] ->
      a == b

Object pretty :=
  if(^Printing member(self)?)
    then: text("...")
    else:
      let(Printing = self . ^Printing):
        pretty-doc

Object show :=
  let(Colored = false):
    pretty flatten render

Doc colored(color) := do:
  unless(^Colored and ^io::OutputPort tty?):
    return(self)

  codes =
    [ .black
      .red
      .green
      .yellow
      .blue
      .magenta
      .cyan
      .white
    ] to-a zip((0 .. 7) to-a)

  hash = Hash [codes]

  raw("\e[9" + hash [color] to-s + "m") <> self <> raw("\e[0m")

Object pretty-doc := text(inspect)
String pretty-doc := text(inspect gsub("\\#", "#")) colored(.yellow)
Integer pretty-doc := super colored(.blue)
Float pretty-doc := super colored(.blue)
TrueClass pretty-doc := super colored(.green)
FalseClass pretty-doc := super colored(.red)
NilClass pretty-doc := super colored(.black)

Doc pretty-doc := self

Array pretty-doc := list(pretty-sequence(self))

Atomy::Particle pretty-doc := do:
  wildcard = [c]:
    if(c equal(_undefined)?)
      then: '_
      else: c

  operator? = @message to-s !~ r"^[a-z_]"

  args = @arguments collect .(wildcard [_])

  msg-args =
    if(operator?)
      then:
        text(@message to-s) <+> args first unamb
      else:
        ident(@message to-s) <>
          tupled(pretty-sequence(args))

  partial =
    if(@receiver equal(_undefined)?)
      then:
        if(operator?)
          then: parens(msg-args)
          else: msg-args
      else: parens(@receiver unamb <+> msg-args)

  text(".") <> partial

Atomy::Particle to-s := show

Symbol pretty-doc := do:
  s = to-s
  if(s =~ r"\[\]=?|[A-Z][a-zA-Z0-9_]*|^[\p{Ll}_][\p{L}_\d\-]*[!?=]?$")
    then: text(".") <> ident(s)
    else: text(".") <> s pretty

Hash pretty-doc :=
  text("#") <>
    align(
      ( lbrace </>
          tree(
            to-a collect [k, v]:
              from(.binary):
                k unamb <+> text("->") <+> v unamb)
      ) nest(2) </>
        rbrace)

Atomy::AST open:
  Block unamb := pretty
  ClassVariable unamb := pretty
  Call unamb := pretty
  Compose unamb :=
    if(from(.binary, .compose)?)
      then: pretty
      else: parens(pretty)
  Constant unamb := pretty
  GlobalVariable unamb := pretty
  (Tree ? @nodes size < 2) unamb := pretty
  InstanceVariable unamb := pretty
  List unamb := pretty
  Primitive unamb := pretty
  QuasiQuote unamb := pretty
  Quote unamb := pretty
  ScopedConstant unamb := pretty
  Send unamb :=
    if(from(.binary, .compose)?)
      then: pretty
      else: parens(pretty)
  Splice unamb := pretty
  String unamb := pretty
  ToplevelConstant unamb := pretty
  Prefix unamb :=
    if(from(.postfix)?)
      then: parens(pretty)
      else: pretty
  Postfix unamb :=
    if(from(.postfix)?)
      then: parens(pretty)
      else: pretty
  Unquote unamb := pretty
  Word unamb := pretty
  Pattern unamb := @pattern unamb
  Node unamb := parens(pretty)

  Binary pretty-doc :=
    from(.binary):
      ((@lhs unamb <+> text(@operator)) </> @rhs unamb) hang(2)

  Block pretty-doc := do:
    args =
      if(@arguments empty?)
        then: empty
        else: list(pretty-sequence(@arguments))

    contents = tree(pretty-sequence(@contents))

    align(args <+> (lbrace </> contents) nest(2) </> rbrace)

  Call pretty-doc := @name pretty <> tupled(pretty-sequence(@arguments))

  Compose pretty-doc := @left pretty <+> @right pretty

  Constant pretty-doc := text(@name)

  Infix pretty-doc :=
    hsep([text(".infix")
          text(@associativity to-s)
          @precedence pretty
          hsep(*(text(o) for o in @operators))])

  List pretty-doc :=
    from(.list):
      list(pretty-sequence(@elements))

  Literal pretty-doc := @value pretty

  Macro pretty-doc :=
    text("macro") <+> parens(@pattern pretty) <+> @body pretty

  Postfix pretty-doc :=
    from(.postfix):
      @receiver unamb <> text(@operator)

  Prefix pretty-doc :=
    from(.prefix):
      text(@operator) <> @receiver unamb

  Primitive pretty-doc :=
    @value match:
      .self -> text("self")
      .true -> text("true")
      .false -> text("false")
      .nil -> text("nil")
      x -> text(x inspect)

  QuasiQuote pretty-doc :=
    from(.prefix):
      text("`") <> @expression unamb

  Quote pretty-doc :=
    from(.prefix):
      text("'") <> @expression unamb

  ScopedConstant pretty-doc :=
    from(.scoped-constant):
      @parent unamb <> text("::") <> text(@name)

  Splice pretty-doc :=
    from(.prefix):
      text("~*") <> @expression unamb

  String pretty-doc := text(@value inspect gsub("\\#", "#"))

  ToplevelConstant pretty-doc := text("::") <> text(@name)

  Unquote pretty-doc :=
    from(.prefix):
      text("~") <> @expression unamb

  Word pretty-doc := ident(@text to-s)

  Tree pretty-doc :=
    if(^Multiline)
      then: from(.top): vcat(pretty-sequence(@nodes))
      else: from(.list): tree(pretty-sequence(@nodes))

  Pattern pretty-doc := @pattern pretty


Atomy::Patterns open:
  And pretty-doc := `(~@a & ~@b) pretty
  Any pretty-doc := text("_")
  Attribute pretty-doc := `(~@receiver ~(Atomy::AST::Word new(-1, @name))) pretty
  BlockPass pretty-doc := `&~@pattern pretty
  Constant pretty-doc := @constant pretty
  Default pretty-doc := `(~@pattern = ~@default) pretty
  HeadTail pretty-doc := `(~@head . ~@tail) pretty
  List pretty-doc := `[~*(@patterns collect .to-node)] pretty
  Literal pretty-doc := @value pretty
  Match pretty-doc := @value pretty
  Named pretty-doc :=
    if(@pattern is-a(Any)?)
      then: text(@name)
      else: text(@name) <> text(":") <+> @pattern pretty
  NamedClass pretty-doc :=
    `(@@~(Atomy::AST::Word new(-1, @identifier))) pretty
  NamedInstance pretty-doc :=
    `(@~(Atomy::AST::Word new(-1, @identifier))) pretty
  NamedGlobal pretty-doc :=
    `($~(Atomy::AST::Word new(-1, @identifier))) pretty
  Or pretty-doc := `(~@a | ~@b) pretty
  Particle pretty-doc :=
    Atomy::Particle new(
      @receiver
      @message
      @arguments patterns) pretty
  Predicate pretty-doc := `(~@pattern ? ~@test) pretty
  QuasiQuote pretty-doc := @quoted pretty
  Quote pretty-doc := `'~@expression pretty
  SingletonClass pretty-doc := @body pretty
  Splat pretty-doc := `*~@pattern pretty
  With pretty-doc := `(~@pattern with(~@expression, ~@sub-pattern)) pretty

  And unamb := parens(pretty)
  Attribute unamb := parens(pretty)
  Default unamb := parens(pretty)
  HeadTail unamb := parens(pretty)
  Named unamb :=
    if(@pattern is-a(Any)?)
      then: pretty
      else: parens(pretty)
  Or unamb := parens(pretty)
  Predicate unamb := parens(pretty)
  With unamb := parens(pretty)
