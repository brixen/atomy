dynamic(atomy-pretty-multiline?, false)
dynamic(atomy-pretty-context, #top)
dynamic(atomy-pretty-colored?, false)

ident(n) := doc: text(n [0, 1] + n [1 .. -1] tr("_", "-") gsub("_ns_", "/"))

pretty-body([]) := []
pretty-body([x]) := [from(#top): x pretty]
pretty-body(x . xs) := [from(#list) { x pretty }] + pretty-body(xs)

module(Atomy::AST):
  Block unamb := pretty
  ClassVariable unamb := pretty
  Compose unamb := doc:
    if(from?(#binary, #compose))
      then: pretty
      else: parens(pretty)
  Constant unamb := pretty
  GlobalVariable unamb := pretty
  (InlinedBody ? @expressions size < 2) unamb := pretty
  (Tree ? @nodes size < 2) unamb := pretty
  InstanceVariable unamb := pretty
  List unamb := pretty
  Particle unamb := pretty
  Primitive unamb := pretty
  QuasiQuote unamb := pretty
  Quote unamb := pretty
  ScopedConstant unamb := pretty
  Send unamb := doc:
    if(from?(#binary, #compose))
      then: pretty
      else: parens(pretty)
  Splice unamb := pretty
  String unamb := pretty
  ToplevelConstant unamb := pretty
  Unary unamb := pretty
  Unquote unamb := pretty
  Variable unamb := pretty
  Node unamb := doc: parens(pretty)
  _ unamb := pretty

from(*where, &y) :=
  let(atomy-pretty-context = where flatten) { y call }

from?(*where) :=
  [^atomy-pretty-context, where] match:
    [(a: List), (b: List)] ->
      a any? [x]: b include?(x)
    [(a: List), b] ->
      a include?(b)
    [a, (b: List)] ->
      b include?(a)
    [a, b] ->
      a == b

String pretty := super colored(#yellow)
Integer pretty := super colored(#blue)
Float pretty := super colored(#blue)
TrueClass pretty := super colored(#green)
FalseClass pretty := super colored(#red)
NilClass pretty := super colored(#black)
Object pretty := doc: text(inspect)

Object show := pretty flatten render

Atomy::Pretty::Doc pretty := self

List pretty := doc: list(all-pretty)

Particle pretty := doc:
  wildcard = [c]:
    if(c equal?(_undefined))
      then: '_
      else: c

  operator? = message to-s !~ r"^[a-z_]"

  args = arguments collect(&#(wildcard [_]))

  msg+args =
    if(operator?)
      then:
        text(message to-s) <+> args first unamb
      else:
        ident(message to-s) <>
          tupled(args all-pretty)

  partial =
    if(receiver equal?(_undefined))
      then:
        if(operator?)
          then: parens(msg+args)
          else: msg+args
      else: parens(receiver unamb <+> msg+args)

  text("#") <> partial

Particle to-s := show

Symbol pretty := doc:
  s = to-s
  if(s =~ r"^[\p{Ll}_]([\p{L}\d\p{S}!@#%&*\-_\\:.\/\?])*$"(u))
    then: text("#") <> ident(s)
    else: text("#") <> s pretty

Hash pretty := doc:
  text("#") <>
    brackets $:
      comma separate $:
        to-a collect [[k, v]]:
          k unamb <+> text("->") <+> v unamb

Map pretty := doc:
  text("#") <>
    brackets $:
      comma separate $:
        reduce([]) [a, k, v]:
          a + [k unamb <+> text("->") <+> v unamb]

module(Atomy::AST):
  Assign pretty := doc:
    from(#assign):
      @lhs unamb <+> text("=") <+> @rhs unamb

  Binary pretty := doc:
    from(#binary):
      ((@lhs unamb <+> text(@operator)) </> @rhs unamb) hang(2)

  Block pretty := doc:
    args =
      if(@arguments empty?)
        then: empty
        else: list(@arguments all-pretty)

    contents = comma separate(pretty-body(@contents))

    if(from?(#send-block) && from?(#top))
      then: args <> colon <+> contents
      else: align(args <+> (lbrace </> contents) nest(2) </> rbrace)

  BlockPass pretty := doc:
    from(#unary):
      text("&") <> @body unamb

  Class pretty := doc:
    sub =
      if(@superclass kind-of?(Primitive) && @superclass value == #nil)
        then: empty
        else: text("<") <+> from(#binary): @superclass unamb

    name =
      @name match:
        Rubinius::AST::ClassName -> text(@name) name to-s
        _ -> @name unamb

    body = lbrace <+> comma separate(@body) expressions <+> rbrace

    text("class") <> text("(") <> name <+> sub <> text(")") <+> body

  ClassVariable pretty := ident(name to-s)

  Compose pretty := doc:
    args =
      from(#list):
        if(@arguments empty?)
          then: empty
          else: tupled(@arguments all-pretty)

    if(@headless)
      then:
        @message unamb <> args
      else:
        (from(#compose) { @receiver unamb } </>
          @message unamb <> args) hang(2)

  Constant pretty := doc: text(@identifier)

  Define pretty := doc:
    from(#binary):
      @pattern unamb <+> text(":=") <+> @body unamb

  GlobalVariable pretty := ident(name to-s)

  InstanceVariable pretty := ident(name to-s)

  List pretty := doc:
    from(#list):
      list(@elements all-pretty)

  Macro pretty := doc:
    text("macro") <+> parens(@pattern pretty) <+> @body pretty

  Primitive pretty := doc:
    @value match:
      #self -> text("self")
      #true -> text("true")
      #false -> text("false")
      #nil -> text("nil")
      x -> text(x inspect)

  QuasiQuote pretty := doc:
    from(#unary):
      text("`") <> @expression unamb

  Quote pretty := doc:
    from(#unary):
      text("'") <> @expression unamb

  ScopedConstant pretty := doc:
    from(#scoped-constant):
      @parent unamb <> text("::") <> text(@identifier)

  Send pretty := doc:
    with-block = [x]:
      when(@block nil?):
        break(x)

      unless(@block is-a?(Block)):
        break(x <+> from(#send-block, ^atomy-pretty-context): @block unamb)

      args =
        if(@block arguments empty?)
          then: empty
          else: list(@block arguments all-pretty)

      align $:
        condition:
          ^atomy-pretty-multiline? && from?(#top) ->
            ( ((x <+> args) <> colon) <$>
                vsep(@block contents all-pretty)
            ) hang(2)

          ^atomy-pretty-multiline? ->
            ( (x <+> args <+> lbrace) <$>
                vsep(@block contents all-pretty)
            ) hang(2) <$> rbrace

          from?(#top) ->
            ( ((x <+> args) <> colon) </>
                comma separate(pretty-body(@block contents))
            ) hang(2)

          otherwise ->
            ( (x <+> args <+> lbrace) </>
                comma separate(pretty-body(@block contents))
            ) hang(2) </> rbrace

    args =
      from(#list):
        if(@arguments empty?)
          then: empty
          else: tupled(@arguments all-pretty)

    condition:
      @receiver kind-of?(Primitive) && @receiver value == #self ->
        with-block [ident(@message-name) <> args]

      otherwise ->
        (from(#compose) { @receiver unamb } </>
          with-block [ident(@message-name) <> args]) hang(2)

  Splice pretty := doc:
    from(#unary):
      text("~*") <> @expression unamb

  String pretty := doc: text(@value inspect)

  ToplevelConstant pretty := doc: text("::") <> text(@identifier)

  Unary pretty := doc:
    from(#unary):
      text(@operator) <> @receiver unamb

  Unquote pretty := doc:
    from(#unary):
      text("~") <> @expression unamb

  Variable pretty := ident(@name)

  InlinedBody pretty := doc:
    from(#top): align(vcat(@expressions all-pretty))

  BlockBody pretty := doc:
    from(#top): align(vcat(@expressions all-pretty))

  Or pretty := `(~@a || ~@b) pretty

  And pretty := `(~@a && ~@b) pretty

  Ensure pretty := doc:
    @body pretty <+> text("ensuring:") <+> @ensure pretty

  Tree pretty := doc:
    if(^atomy-pretty-multiline?)
      then: from(#top): vcat(@nodes all-pretty)
      else: from(#list): comma separate(@nodes all-pretty)

List all-pretty := collect [x]: x pretty

Atomy::Pretty::Doc colored(color) := doc:
  -- only makes sense to colorize if we're outputting to a terminal
  unless(^atomy-pretty-colored? && ^output-port tty?):
    return(self)

  codes =
    [ #black
      #red
      #green
      #yellow
      #blue
      #magenta
      #cyan
      #white
    ] to-a zip((0 .. 7) to-a)

  hash = Hash [codes]

  raw("\e[9" + hash [color] to-s + "m") <> self <> raw("\e[0m")
