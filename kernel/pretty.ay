namespace(atomy/pretty)

dynamic(multiline?, false)
dynamic(context, #top)

comma-delim(ds) :=
  hsep(comma punctuate(ds))

ident(n) := text(n [0, 1] + n [1 .. -1] tr("_", "-") gsub("_ns_", "/"))

module(Atomy::AST):
  Block unamb := pretty
  ClassVariable unamb := pretty
  Constant unamb := pretty
  GlobalVariable unamb := pretty
  (InlinedBody ? @contents size < 2) unamb := pretty
  InstanceVariable unamb := pretty
  List unamb := pretty
  Particle unamb := pretty
  Primitive unamb := pretty
  QuasiQuote unamb := pretty
  Quote unamb := pretty
  ScopedConstant unamb := pretty
  Send unamb :=
    if([#binary, #send] include?(^context))
      then: pretty
      else: Doc parens(pretty)
  Splice unamb := pretty
  String unamb := pretty
  ToplevelConstant unamb := pretty
  Unary unamb := pretty
  Unquote unamb := pretty
  Variable unamb := pretty
  Node unamb := Doc parens(pretty)

from(context, &y) :=
  let(context = context, &y)

export-to(atomy):
  Object pretty := Doc text(inspect)

  Object show := pretty render

  Array pretty :=
    doc: brackets(comma-delim(self all-pretty))

  Particle pretty := doc:
    wildcard = [c]:
      if(c equal?(_undefined))
        then: '_
        else: c

    operator? = self message to-s !~ r"^[a-z_]"

    args = self arguments collect(&#(wildcard [_]))

    msg+args =
      if(operator?)
        then:
          text(self message to-s) <+> args first unamb
        else:
          ident(self message to-s) <>
            parens(comma-delim(args all-pretty))

    partial =
      if(self receiver equal?(_undefined))
        then:
          if(operator?)
            then: parens(msg+args)
            else: msg+args
        else: parens(self receiver unamb <+> msg+args)

    text("#") <> partial

  Particle to-s := pretty render

  Symbol pretty := do:
    s = to-s
    if(s =~ r(u)"^[\p{Ll}_]([\p{L}\d\p{S}!@#%&*\-_\\:.\/\?])*$")
      then: Doc text("#") <> Doc ident(s)
      else: Doc text("#") <> s pretty

  Hash pretty := doc:
    text("#") <>
      brackets(
        comma-delim(
          self to-a collect [[k, v]]:
            k unamb <+> text("->") <+> v unamb))

  module(Atomy::AST):
    Assign pretty :=
      from(#assign):
        doc: @lhs unamb <+> text("=") <+> @rhs unamb

    BinarySend pretty :=
      from(#binary):
        doc: @lhs unamb <+> text(@operator) <+> @rhs unamb

    Block pretty :=
      from(#top):
        doc:
          args =
            if(@arguments empty?)
              then: empty
              else: parens(comma-delim(@arguments all-pretty))

          args <> lbrace <+> comma-delim(@contents all-pretty) <+> rbrace

    BlockPass pretty :=
      from(#unary):
        doc: text("&") <> @body unamb

    Class pretty := doc:
      sub =
        if(@superclass kind-of?(Primitive) && @superclass value == #nil)
          then: empty
          else: text("<") <+> from(#binary): @superclass unamb

      name =
        @name match:
          Rubinius::AST::ClassName -> text(@name) name to-s
          _ -> @name unamb

      body = lbrace <+> semi-delim(@body) expressions <+> rbrace

      text("class") <> text("(") <> name <+> sub <> text(")") <+> body

    ClassVariable pretty := doc: ident(name to-s)

    Constant pretty := doc: text(@identifier)

    Define pretty :=
      from(#define):
        doc: @lhs unamb <+> text(":=") <+> @body unamb

    GlobalVariable pretty := doc: ident(name to-s)

    InstanceVariable pretty := doc: ident(name to-s)

    List pretty :=
      from(#top):
        doc: brackets(comma-delim(@elements all-pretty))

    Macro pretty := doc:
      text("macro") <+> parens(@pattern pretty) <+> @body pretty

    Particle pretty := doc: text("#") <> ident(@name)

    Primitive pretty := doc:
      @value match:
        -- TODO: glitch with #doc/#onto
        #"self" -> text("self")
        #true -> text("true")
        #false -> text("false")
        #nil -> text("nil")
        x -> x pretty

    QuasiQuote pretty :=
      from(#unary):
        doc: text("`") <> @expression unamb

    Quote pretty :=
      from(#unary):
        doc: text("'") <> @expression unamb

    ScopedConstant pretty :=
      from(#scoped-constant):
        doc:
          @parent unamb <> text("::") <> text(name to-s)

    Send pretty :=
      doc:
        block = if(@block) then: @block unamb; else: empty

        with-block = [x]:
          if(^multiline? && @block is-a?(Block))
            then:
              cs = vcat(@block contents all-pretty) nest(2)
              if(^context == #top)
                then: x <> colon // cs
                else: x <+> lbrace // cs // rbrace
            else: x <+> block

        args =
          from(#top):
            if(@arguments empty?)
              then: empty
              else: parens(comma-delim(@arguments all-pretty))

        condition:
          @receiver kind-of?(Primitive) && @receiver value == #"self" ->
            with-block [ident(@method-name) <> args]

          otherwise ->
            with-block [from(#send) { @receiver unamb } <+> ident(@method-name) <> args]

    Splice pretty :=
      from(#unary):
        doc: text("~*") <> @expression unamb

    String pretty := @value pretty

    ToplevelConstant pretty := doc: text("::") <> text(name to-s)

    Unary pretty :=
      from(#unary):
        doc: text(@operator) <> @receiver unamb

    Unquote pretty :=
      from(#unary):
        doc: text("~") <> @expression unamb

    Variable pretty := doc: ident(@name)

    InlinedBody pretty :=
      from(#top):
        doc:
          hsep(comma punctuate(@expressions collect [e]: e pretty))

    Or pretty := `(~@a || ~@b) pretty

    And pretty := `(~@a && ~@b) pretty

    Ensure pretty := doc:
      @body pretty <+> text("ensuring:") <+> @ensure pretty


Array all-pretty := collect [x]: x pretty
