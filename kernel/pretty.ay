use("core")
use("define")
use("control-flow")
use("cosmetics")
use("particles")
use("comparison")
use("range")
use("regexp")
use("array")

use("dynamic")
doc = use("doc")
io = require("io")

Printing = dynamic([])
Multiline = dynamic(false)
Context = dynamic(.top)
Colored = dynamic(false)

ident(n) =
  if(n =~ r"^__")
    then: doc text(n)
    else: doc text(n [0, 1] + n [1 .. -1] tr("_", "-"))

from(*where) &y =
  let(Context = where flatten):
    y call

from(*where)? =
  [^Context, where] match:
    [(a: Array), (b: Array)] ->
      a any? .(is-in b)

    [(a: Array), b] ->
      b is-in a

    [a, (b: Array)] ->
      a is-in b

    [a, b] ->
      a == b

render-sequence([]) = []
render-sequence([x]) = [from(.top): render(x)]
render-sequence(x . xs) = [from(.list): render(x)] + render-sequence(xs)

tree(xs) = align(fill-sep(comma punctuate(xs)))

colored(color, doc) = do:
  unless(^Colored and ^(io OutputPort) tty?):
    return(doc)

  codes =
    [ .black
      .red
      .green
      .yellow
      .blue
      .magenta
      .cyan
      .white
    ] to-a zip((0 .. 7) to-a)

  hash = Hash [codes]

  raw("\e[9" + hash [color] to-s + "m") <> doc <> raw("\e[0m")

unamb(x) := render(x)

render(x) :=
  if(x is-in ^Printing)
    then: text("...")
    else:
      let(Printing = x . ^Printing):
        doc(x)

show(x) :=
  let(Colored = false):
    render(x) flatten render

puts(x) := x tap: ^(io OutputPort) puts(show(x))
print(x) := x tap: ^(io OutputPort) print(show(x))

doc(o: Object) := text(o inspect)
doc(s: String) := colored(.yellow, text(s inspect gsub("\\#", "#")))
doc(x: Integer) := colored(.blue, text(x inspect))
doc(x: Float) := colored(.blue, text(x inspect))
doc(true) := colored(.green, text("true"))
doc(false) := colored(.red, text("false"))
doc(nil) := colored(.black, text("nil"))
doc(? equal(_)?) := colored(.black, text("_"))
doc(d: Doc) := d
doc(a: Array) := list(render-sequence(a))

doc(p: Atomy Particle) := do:
  operator? = p message to-s !~ r"^[a-z_]"

  msg-args =
    if(operator?)
      then:
        text(p message to-s) <+> unamb(p arguments first)
      else:
        ident(p message to-s) <>
          tupled(render-sequence(p arguments))

  partial =
    if(p receiver equal(_)?)
      then:
        if(operator?)
          then: parens(msg-args)
          else: msg-args
      else: parens(unamb(p receiver) <+> msg-args)

  text(".") <> partial

doc(s: Symbol) := do:
  str = s to-s
  if(str =~ r"\[\]=?|[A-Z][a-zA-Z0-9_]*|^[\p{Ll}_][\p{L}_\d\-]*[!?=]?$")
    then: text(".") <> ident(str)
    else: text(".") <> doc(str)

doc(h: Hash) :=
  text("#") <>
    align(
      ( lbrace </>
          tree(
            h to-a collect [k, v]:
              from(.binary):
                unamb(k) <+> text("->") <+> unamb(v))
      ) nest(2) </>
        rbrace)

doc(w: Atomy AST Word) := ident(w text to-s)

Atomy AST open:
  Self unamb(
      x:
        Block
          | ClassVariable
          | Call
          | Constant
          | GlobalVariable
          | (Tree ? @nodes size < 2)
          | InstanceVariable
          | List
          | Primitive
          | ScopedConstant
          | String
          | ToplevelConstant
          | Word) :=
    render(x)
  Self unamb(c: Compose) :=
    if(from(.binary, .compose)?)
      then: render(c)
      else: parens(render(c))
  Self unamb(s: Send) :=
    if(from(.binary, .compose)?)
      then: render(s)
      else: parens(render(s))
  Self unamb(p: Prefix | Postfix | QuasiQuote | Quote | Unquote) :=
    if(from(.postfix)?)
      then: parens(render(p))
      else: render(p)
  Self unamb(p: Pattern) :=
    unamb(p pattern)
  Self unamb(n: Node) :=
    parens(render(n))


  Self doc(b: Binary) :=
    from(.binary):
      ( if(b private)
          then:
            text(b operator) </> unamb(b rhs)
          else:
            unamb(b lhs) <+> text(b operator) </> unamb(b rhs)
      ) hang(2)

  Self doc(b: Block) := do:
    args =
      if(b arguments empty?)
        then: empty
        else: list(render-sequence(b arguments))

    contents = tree(render-sequence(b contents))

    align(args <+> (lbrace </> contents) nest(2) </> rbrace)

  Self doc(c: Call) :=
    render(c name) <> tupled(render-sequence(c arguments))

  Self doc(c: Compose) := render(c left) <+> render(c right)

  Self doc(c: Constant) := text(c name)

  Self doc(l: List) :=
    from(.list):
      list(render-sequence(l elements))

  Self doc(l: Literal) := render(l value)

  Self doc(p: Postfix) :=
    from(.postfix):
      unamb(p receiver) <> text(p operator)

  Self doc(p: Prefix) :=
    from(.prefix):
      text(p operator) <> unamb(p receiver)

  Self doc(p: Primitive) :=
    p value match:
      .self -> text("self")
      .true -> text("true")
      .false -> text("false")
      .nil -> text("nil")
      x -> text(x inspect)

  Self doc(q: QuasiQuote) :=
    from(.prefix):
      text("`") <> unamb(q expression)

  Self doc(q: Quote) :=
    from(.prefix):
      text("'") <> unamb(q expression)

  Self doc(s: ScopedConstant) :=
    from(.scoped-constant):
      unamb(s parent) <> text("::") <> text(s name)

  Self doc(s: String) := text(s value inspect gsub("\\#", "#"))

  Self doc(t: ToplevelConstant) :=
    text("::") <> text(t name)

  Self doc(u: Unquote) :=
    from(.prefix):
      text("~") <> unamb(u expression)

  Self doc(w: Word) := ident(w text to-s)

  Self doc(t: Tree) :=
    if(^Multiline)
      then: from(.top): vcat(render-sequence(t nodes))
      else: from(.list): tree(render-sequence(t nodes))

  Self doc(p: Pattern) := render(p pattern)


Atomy Patterns open:
  Self doc(a: And) := render(`(~(a a) & ~(a b)))
  Self doc(Any) := text("_")
  Self doc(a: Attribute) :=
    render(`(~(a receiver) ~(Atomy AST Word new(-1, a name))))
  Self doc(b: BlockPass) := render(`&~(b pattern))
  Self doc(c: Constant) := render(c constant)
  Self doc(d: Default) := render(`(~(d pattern) = ~(d default)))
  Self doc(h: HeadTail) := render(`(~(h head) . ~(h tail)))
  Self doc(l: List) := list(render-sequence(@patterns))
  Self doc(l: Literal) := render(l value)
  Self doc(m: Match) := render(m value)
  Self doc(n: Named) :=
    if(n pattern is-a(Any)?)
      then: text(n name)
      else: text(n name) <> text(":") <+> render(n pattern)
  Self doc(n: NamedClass) :=
    render(`(@@~(Atomy AST Word new(-1, n identifier))))
  Self doc(n: NamedInstance) :=
    render(`(@~(Atomy AST Word new(-1, n identifier))))
  Self doc(n: NamedGlobal) :=
    render(`($~(Atomy AST Word new(-1, n identifier))))
  Self doc(o: Or) :=
    render(`(~(o a) | ~(o b)))
  Self doc(p: Particle) :=
    render(
      Atomy Particle new(
        p receiver
        p message
        p arguments patterns))
  Self doc(p: Predicate) := render(`(~(p pattern) ? ~(p test)))
  Self doc(q: QuasiQuote) := render(q quoted)
  Self doc(q: Quote) := render(`'~(q expression))
  Self doc(s: SingletonClass) := render(s body)
  Self doc(s: Splat) := render(`*~(s pattern))
  Self doc(w: With) :=
    render(`(~(w pattern) with(~(w expression), ~(w sub-pattern))))

  Self unamb(
      x: And | Attribute | Default | HeadTail | Or | Predicate | With) :=
    parens(render(x))
  Self unamb(n: Named) :=
    if(n pattern is-a(Any)?)
      then: render(n)
      else: parens(render(n))
