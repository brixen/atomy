macro (&x)
  Atomo::AST::BlockPass new(x line, x)

macro (*x)
  Atomo::AST::Splat new(x line, x)

macro (@(x: Variable))
  Atomo::AST::InstanceVariable new(x line, x name)

macro (@@(x: Variable))
  Atomo::AST::ClassVariable new(x line, x name)

macro ($(x: 'exception))
  Atomo::AST::GlobalVariable new(x line, "!")

macro ($(x: Variable))
  Atomo::AST::GlobalVariable new(x line, x name)

macro (#(b: Block))
  { keys = []
    values = []

    b contents each { p |
      p match: {
        `(~k -> ~v) ->
          { keys << k
            values << v
          } call

        (v: Atomo::AST::KeywordSend) ->
          { keys << Atomo::AST::Particle new(v line, v names first)
            values << v arguments first
          } call
      }
    }

    Atomo::AST::Hash new(line, keys, values)
  } call

a .. b := Range new(a, b)
a ... b := Range new(a, b, true)

for-macro quote: #w as: { c | c split }

-- TODO: flags
for-macro quote: #r as: { c | Regexp new(c) }

for-macro quote: #raw as: { c | c }

class(Atomo::AST::Hash < Atomo::AST::Node) {
  children([#keys], [#values])
  generate

  bytecode(g) :=
    { g push_cpath_top
      g find_const(#Hash)
      g push_int(@keys size)
      g send(#new_from_literal, 1)

      @keys each_with_index { n i |
        g dup
        n bytecode(g)
        @values at(i) bytecode(g)
        g send("[]=" to_sym, 2)
        g pop
      }
    } call
}
