macro(let-when(when, *bindings, &b)):
  tmps = names(bindings size)
  save = []
  set = []
  restore = []

  bindings zip(tmps) ([`(~n = ~v), tmp]):
    save << `(Atomy::STATE [#~tmp] = ^~n)
    set << set-dynvar(n, v)
    restore << set-dynvar(n, `(Atomy::STATE delete(#~tmp)))

  names (res):
    `(let(~*bindings):
        evaluate-when(~when):
          ~*save
          ~*set

        ~res = ~(b body)

        evaluate-when(~when):
          ~restore

        ~res)

macro(in-namespace(n, &b)):
  `(let-when(compile, namespace = Atomy::Namespace ensure(#~n)):
      ~(b body))

macro(no-namespace(&b)):
  `(let-when(compile, namespace = nil):
      ~(b body))

macro(export(&b)):
  `(let-when(compile, define-in = "_"):
      ~(b body))

macro(export-to(n, &b)):
  `(let-when(compile, define-in = ~(n name)):
      ~(b body))

macro(use(*ns)):
  `(evaluate-when(compile, run):
      ~*(ns collect (n):
          `(Atomy::Namespace get use(#~n))))

macro(symbols(*ns)):
  `(evaluate-when(compile, run):
      ~*(ns collect (n):
          `(Atomy::Namespace register(#~n))))

namespace(atomy)
