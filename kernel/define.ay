macro('do ~(b: Block)): b body

--macro(x = y):
  --Assign new(x line, x, y)

macro(x =! y):
  Set new(x line, x, y)

macro(pattern := y):
  x = pattern expand

  where = Atomy::Namespace define-target
  Atomy::Namespace register(x namespace-symbol, where)

  Atomy::CodeLoader when-load <<
    [`(Atomy::Namespace register(~(x namespace-symbol), ~where)), true]

  Atomy::CodeLoader when-run <<
    [`(Atomy::Namespace register(~(x namespace-symbol), ~where)), true]

  Define new(line, x, y)

macro(define(x) ~(y: Block)):
  `(~x := ~(y block-body))

macro(x **= y): `(~x =! (~x ** ~y))
macro(x *= y): `(~x =! (~x * ~y))
macro(x <<= y): `(~x =! (~x << ~y))
macro(x >>= y): `(~x =! (~x >> ~y))
macro(x &&= y): `(~x =! (~x && ~y))
macro(x &= y): `(~x =! (~x & ~y))
macro(x ||= y): `(~x =! (~x || ~y))
macro(x |= y): `(~x =! (~x | ~y))
macro(x += y): `(~x =! (~x + ~y))
macro(x -= y): `(~x =! (~x - ~y))
macro(x /= y): `(~x =! (~x / ~y))
macro(x ^= y): `(~x =! (~x ^ ~y))
macro(x %= y): `(~x =! (~x % ~y))

macro(x match ~(b: Block)):
  branches = b contents collect [`(~x -> ~y)]:
    MatchBranch new(x line, y, x)

  Match new(line, x, branches)

macro(class(name) ~(b: Block)):
  Class new(name line, name, b block-body)

macro(class(`(<< ~obj)) ~(b: Block)):
  SingletonClass new(obj line, obj, b block-body)

macro(class(`(~name < ~sup)) ~(b: Block)):
  Class new(name line, name, b block-body, sup)

macro(module(name) ~(b: Block)):
  Module new(name line, name, b block-body)

macro(evaluate-when('compile) ~(x: Block)):
  x body evaluate
  'nil

macro(evaluate-when('load) ~(x: Block)):
  Atomy::CodeLoader when-load << [x block-body, false]
  'nil

macro(evaluate-when('run) ~(x: Block)):
  Atomy::CodeLoader when-run << [x block-body, false]
  'nil

macro(evaluate-when('compile, 'load) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  'nil

macro(evaluate-when('compile, 'run) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('load, 'compile) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  'nil

macro(evaluate-when('load, 'run) ~(x: Block)):
  Atomy::CodeLoader when-load << [x block-body, false]
  Atomy::CodeLoader when-run << [x block-body, false]
  'nil

macro(evaluate-when('run, 'load) ~(x: Block)):
  Atomy::CodeLoader when-load << [x block-body, false]
  Atomy::CodeLoader when-run << [x block-body, false]
  'nil

macro(evaluate-when('run, 'compile) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('compile, 'load, 'run) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('compile, 'run, 'load) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('load, 'compile, 'run) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('load, 'run, 'compile) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('run, 'load, 'compile) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('run, 'compile, 'load) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro('for-macro ~(b: Block)):
  `(evaluate-when(compile, load, run):
      module(Atomy::Macro::Helpers):
        ~*(b contents))

macro(let-macro(*ms) ~(body: Block)):
  macros = ms collect [`(~p = ~b)]:
    Macro new(p line, p, b)

  LetMacro new(line, body caller, macros)
