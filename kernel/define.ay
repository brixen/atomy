macro('do ~(b: Block)): b body

--macro(x = y):
  --Assign new(x line, x, y)

macro(x =! y):
  Set new(x line, x to-pattern to-node, y)

macro(pattern := y):
  Define new(line, pattern expand, y)

macro(define(x) ~(y: Block)):
  `(~x := ~(y block-body))

macro(x **= y): `(~x =! (~x ** ~y))
macro(x *= y): `(~x =! (~x * ~y))
macro(x <<= y): `(~x =! (~x << ~y))
macro(x >>= y): `(~x =! (~x >> ~y))
macro(x &&= y): `(~x =! (~x && ~y))
macro(x &= y): `(~x =! (~x & ~y))
macro(x ||= y): `(~x =! (~x || ~y))
macro(x |= y): `(~x =! (~x | ~y))
macro(x += y): `(~x =! (~x + ~y))
macro(x -= y): `(~x =! (~x - ~y))
macro(x /= y): `(~x =! (~x / ~y))
macro(x ^= y): `(~x =! (~x ^ ~y))
macro(x %= y): `(~x =! (~x % ~y))

macro(class(name) ~(b: Block)):
  Class new(name line, name, b block-body)

macro(class(`(<< ~obj)) ~(b: Block)):
  SingletonClass new(obj line, obj, b block-body)

macro(class(`(~name < ~sup)) ~(b: Block)):
  Class new(name line, name, b block-body, sup)

macro(module(name) ~(b: Block)):
  Module new(name line, name, b block-body)

macro(evaluate-when('compile) ~(x: Block)):
  x body evaluate
  'nil

macro(evaluate-when('load) ~(x: Block)):
  Atomy::CodeLoader when-load << [x block-body, false]
  'nil

macro(evaluate-when('run) ~(x: Block)):
  Atomy::CodeLoader when-run << [x block-body, false]
  'nil

macro(evaluate-when('compile, 'load) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  'nil

macro(evaluate-when('compile, 'run) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('load, 'compile) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  'nil

macro(evaluate-when('load, 'run) ~(x: Block)):
  Atomy::CodeLoader when-load << [x block-body, false]
  Atomy::CodeLoader when-run << [x block-body, false]
  'nil

macro(evaluate-when('run, 'load) ~(x: Block)):
  Atomy::CodeLoader when-load << [x block-body, false]
  Atomy::CodeLoader when-run << [x block-body, false]
  'nil

macro(evaluate-when('run, 'compile) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('compile, 'load, 'run) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('compile, 'run, 'load) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('load, 'compile, 'run) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('load, 'run, 'compile) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('run, 'load, 'compile) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro(evaluate-when('run, 'compile, 'load) ~(x: Block)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  Atomy::CodeLoader when-run << [x block-body, true]
  'nil

macro('for-macro ~(b: Block)):
  `(evaluate-when(compile, load, run):
      module(Atomy::Macro::Helpers):
        ~*(b contents))

-- TODO: compare let-when; make a more general macro for wrapping
-- with evaluate-when
macro(let-macro(*ms) ~(b: Block)):
  tripled = ms zip(names(ms size) zip(names(ms size)))

  define =
    tripled collect [[`(~p = ~b), [let, mac]]]:
      `(do:
          Atomy::STATE [#~mac] =
            (~mac = Atomy::AST::Macro new(~(p line), '~p, '~b))

          Atomy::STATE [#~let] =
            Atomy::Macro register(
              ~mac pattern class
              ~mac macro-pattern
              ~mac prepared
              Atomy::CodeLoader compiling
              true
            ))

  unwind =
    tripled collect [[_, [let, mac]]]:
      `(do:
          ~mac = Atomy::STATE [#~mac] pattern

          ~mac class remove-method(Atomy::STATE [#~let])

          when(lets = Atomy::Macro::Environment let [~mac class]):
            lets delete(Atomy::STATE [#~let])

            when(lets empty?):
              Atomy::Macro::Environment let delete(~mac class))

  names [res]:
    `(do:
        evaluate-when(compile):
          ~*define

        ~res = ~(b block-body)

        evaluate-when(compile):
          ~*unwind

        ~res)
