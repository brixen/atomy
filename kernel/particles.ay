use("core")
use("define")
use("data")
use("control-flow")
use("cosmetics")
use("comparison")

Atomy open:
  data(Particle(@receiver, @message, @arguments))

  Particle call(*args) &blk := to-proc [*args] &blk

  Particle open:
    alias-method(.[], .call)

  Particle to-proc := [*args] &blk:
    [recv, cur] =
      if(@receiver equal(_)?)
        then: [args[0], 1]
        else: [@receiver, 0]

    filled =
      @arguments collect [v]:
        if(v equal(_)? and args size < cur)
          then:
            cur += 1
            args[cur - 1]
          else:
            v

    recv __send__(@message, *filled) &blk

  Particle arity :=
    (@receiver . @arguments) select .equal(_)? size

Symbol call(*args) &blk := to-proc [*args] &blk

Symbol arity := 1

macro(.[~*(as: _ . _)]):
  `(Atomy Particle new(_, .[], ~as))

macro(.((~x)(~*as))):
  `(Atomy Particle new(_, .~x, ~as))

macro(.((~x)(~*as))?):
  `(Atomy Particle new(_, .(~x)?, ~as))

macro(.((~x)(~*as))!):
  `(Atomy Particle new(_, .(~x)!, ~as))

macro(.(~r (~x)(~*as))):
  `(Atomy Particle new(~r, .~x, ~as))

macro(.(~r (~x)(~*as))?):
  `(Atomy Particle new(~r, .(~x)?, ~as))

macro(.(~r (~x)(~*as))!):
  `(Atomy Particle new(~r, .(~x)!, ~as))

macro(.(~r [~*as])):
  `(Atomy Particle new(~r, .[], ~as))

macro(.~(x: Binary)):
  `(Atomy Particle new(
      ~(if(x private)
          then: '_
          else: x lhs)
      ~(x operator)
      [~(x rhs)]))


Atomy Patterns open:
  Particle = Pattern class:
    children(.receiver, .arguments)
    attributes(.message)
    generate

    target(g) := do:
      g push-cpath-top
      g find-const(.Atomy)
      g find-const(.Particle)

    matches(g)? := do:
      mismatch = g new-label
      done = g new-label

      g dup
      target(g)
      g swap
      g kind-of
      g gif(mismatch)

      g dup
      g send(.message, 0)
      g push-literal(@message)
      g send(."==", 1)
      g gif(mismatch)

      g dup
      g send(.receiver, 0)
      @receiver matches(g)?
      g gif(mismatch)

      g send(.arguments, 0)
      @arguments matches(g)?
      g dup
      g git(done)

      mismatch set!
      g pop
      g push-false

      done set!

    deconstruct(g, locals = _ Hash new) := do:
      g dup
      g send(.receiver, 0)
      @receiver deconstruct(g, locals)

      g send(.arguments, 0)
      @arguments deconstruct(g, locals)

`.(~r [~*as]) to-pattern :=
  Atomy Patterns Particle new(
    r to-pattern
    .[]
    `[~*as] to-pattern)

`.[] to-pattern :=
  Atomy Patterns Literal new(.[])

`.[~*as] to-pattern :=
  Atomy Patterns Particle new(
    '_ to-pattern
    .[]
    `[~*as] to-pattern)

`.~(x: Atomy AST Binary) to-pattern :=
  Atomy Patterns Particle new(
    if(x private)
      then: '_ to-pattern
      else: x lhs to-pattern
    `[~(x rhs)] to-pattern
    x operator)

`.((~(x: Atomy AST Word))(~*as)) to-pattern :=
  Atomy Patterns Particle new(
    '_ to-pattern
    `[~*as] to-pattern
    x text)

`.((~(x: Atomy AST Word))(~*as)?) to-pattern :=
  Atomy Patterns Particle new(
    '_ to-pattern
    `[~*as] to-pattern
    `((~x)?) to-word text)

`.((~(x: Atomy AST Word))(~*as)!) to-pattern :=
  Atomy Patterns Particle new(
    '_ to-pattern
    `[~*as] to-pattern
    `((~x)!) to-word text)

`.(~r (~(x: Atomy AST Word))(~*as)) to-pattern :=
  Atomy Patterns Particle new(
    r to-pattern
    `[~*as] to-pattern
    x text)

`.(~r (~(x: Atomy AST Word))(~*as)?) to-pattern :=
  Atomy Patterns Particle new(
    r to-pattern
    `[~*as] to-pattern
    `((~x)?) to-word text)

`.(~r (~(x: Atomy AST Word))(~*as)!) to-pattern :=
  Atomy Patterns Particle new(
    r to-pattern
    `[~*as] to-pattern
    `((~x)!) to-word text)
