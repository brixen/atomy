require("kpeg")
require("set")

for-macro:
  process-val(g, `(~a ~b)) :=
    `(~g seq(~process-val(g, a), ~process-val(g, b)))

  process-val(g, `(~a | ~b)) :=
    `(~g any(~process-val(g, a), ~process-val(g, b)))

  process-val(g, a: `{ ~*bs }) :=
    if(^actions)
      then:
        vars = ^rule-vars to-a
        call = i"actions[#{^actions size}][#{vars join(\", \")}]"
        ^actions << [a, ^rule-vars to-a]
        `(~g action(~call))
      else:
        `(~g action({ ~*bs }))

  process-val(g, `<(~x)) := do:
    when(^rule-vars): ^rule-vars << "text"
    `(~g collect(~process-val(g, x)))

  process-val(g, `@<(~x)) :=
    `(~g bounds(~process-val(g, x)))

  process-val(g, `[~*xs]) :=
    `(~g any(~*(xs map [x]: process-val(g, x))))

  process-val(g, s: Atomy::AST::String) :=
    `(~g str(~s))

  process-val(g, `/~(b: Atomy::AST::String)) :=
    `(~g reg(~(b raw)))

  process-val(g, c: Atomy::AST::Call) := do:
    args = "(" + c arguments collect(&#show) join(", ") + ")"

    `(~g ref(~(c name text), nil, ~args))

  process-val(g, `@~(c: Atomy::AST::Call)) := do:
    args = "(" + c arguments collect(&#show) join(", ") + ")"

    `(~g invoke(~(c name text), ~args))

  process-val(g, `^~(c: Atomy::AST::Call)) := do:
    args = "(" + c arguments collect(&#show) join(", ") + ")"

    `(~g foreign-invoke("parent", ~(c name text), ~args))

  process-val(g, `%~(c: Atomy::AST::Call)) := do:
    [gram, name] = c name text split(".")
    args = "(" + c arguments collect(&#show) join(", ") + ")"

    `(~g foreign-invoke(~gram, ~name, ~args))

  process-val(g, w: Atomy::AST::Word) :=
    `(~g ref(~(w text)))

  process-val(g, `@~(w: Atomy::AST::Word)) := do:
    `(~g invoke(~(w text)))

  process-val(g, `^~(w: Atomy::AST::Word)) := do:
    `(~g foreign-invoke("parent", ~(w text)))

  process-val(g, `%~(w: Atomy::AST::Word)) := do:
    [gram, name] = w text split(".")
    `(~g foreign-invoke(~gram, ~name))

  process-val(g, `=~(name)(~v)) := do:
    when(^rule-vars): ^rule-vars << name text
    `(~g t(~process-val(g, v), ~(name text)))

  process-val(g, `?~v) :=
    `(~g maybe(~process-val(g, v)))

  process-val(g, `+~v) :=
    `(~g many(~process-val(g, v)))

  process-val(g, `*~v) :=
    `(~g kleene(~process-val(g, v)))

  process-val(g, `&~v) :=
    `(~g andp(~process-val(g, v)))

  process-val(g, `!~v) :=
    `(~g notp(~process-val(g, v)))

  process-val(g, '_) :=
    `(~g dot)

  process-val(_, s) := error(#unknown-op(s))

  class(Atomy::AST::ParserDefiner < Atomy::AST::Node):
    attributes(#source)
    generate

    bytecode(g) := do:
      g push-rubinius
      g push-literal(#"__parser_init__")
      g push-literal(Rubinius::Compiler compile-string(@source))
      g push-scope
      g push-self
      g send(#attach-method, 4)
      g pop

      g push-self
      g send(#"__parser_init__", 0)


macro(grammar: ~*body): names [g]:
  b = body collect [n]:
    n match:
      `%%{ ~*xs } -> do:
        call =
          if(^setups)
            then:
              ^setups << `{ ~*xs }
              i"setups[#{^setups size - 1}][]"
            else:
              `{ ~*xs }

        `(~g add-setup(~g action(~call)))

      `(%~name := ~const) ->
        `(~g add-foreign-grammar(~(name text), ~(const show)))

      `(%~name = ~expr) -> do:
        call =
          if(^vars)
            then:
              ^vars << `{ ~*xs }
              i"vars[#{^vars size - 1}][]"
            else:
              `{ ~*xs }

        `(~g set-variable(~(name text), call))

      `(~(name)(~*args) := ~val) ->
        let(rule = name text,
            rule-vars = ::Set new(args to-a collect(&#text))):
          `(~g set(~(name text), ~process-val(g, val), ~(args collect(&#text))))

      `(~name := ~val) ->
        let(rule = name text,
            rule-vars = ::Set new):
          `(~g set(~(name text), ~process-val(g, val)))

      _ -> `unknown(~n)

  `(KPeg::Grammar new tap [~g]: ~*b)


macro(parser(~name): ~*grammar):
  let(actions = Array[],
      setups = Array[],
      vars = Array[]):
    g = `(grammar: ~*grammar) evaluate

    actions = ^actions collect [[a, as]]:
      args = as collect [a]: word(a)
      `([~*args] ~a)

    def = Atomy::AST::ParserDefiner new(
      line
      KPeg::CodeGenerator new(name show, g) output
    )

    `(do:
        class(~name < KPeg::CompiledParser):
          { self } setups := @setups ||= ~^setups
          { self } vars := @vars ||= ~^vars

          actions := @actions ||= ~actions

        ~def)
