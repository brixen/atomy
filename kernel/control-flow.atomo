macro (if(x) then(&y) else(&z))
  Atomo::AST::IfThenElse new(line, x, y, z)
  
macro (otherwise) 'true

macro (condition(&bs))
  bs contents reverse inject('nil) (acc, `(~x -> ~y)):
    `(if(~x) then: ~y; else: ~acc)

macro (while(cond, &body))
  Atomo::AST::While new(line, cond, `(~body call))

macro (until(cond, &body))
  Atomo::AST::While new(line, `!~cond, `(~body call))

macro (return(y))
  Atomo::AST::Return new(line, y)

macro (begin(&x) rescue(&y))
  Atomo::AST::Catch new(line, x body, `(~y call($exception)))

macro (begin(&x) rescue(&y) else(&z))
  Atomo::AST::Catch new(line, x body, `(~y call($exception)), z body)

macro (x ensuring(&y))
  Atomo::AST::Ensure new(line, `(~x call), `(~y call))

unless(false, &blk) := blk call
unless(nil, &blk) := blk call
unless(_, &_) := nil

when(false, &_) := nil
when(nil, &_) := nil
when(_, &blk) := blk call

macro (super) Atomo::AST::ZSuper new(line)

macro (super(*args, &blk)) Atomo::AST::Super new(line, args, blk)

module(Atomo::AST):
  class(ZSuper < Node):
    generate

    bytecode(g) := do:
      pos(g)

      g push-block

      if(g state super?)
        then:
          g zsuper(g state super name)
        else:
          g zsuper(nil)

  class(Super < Node):
    children([#arguments], #block?)
    generate

    bytecode(g) := do:
      pos(g)

      block = @block
      when(@arguments last kind-of?(BlockPass)):
        block =! @arguments pop

      splat = @arguments select (n): n kind-of?(Splat); at(0)
      when(splat):
        @arguments reject! (n): n kind-of?(Splat)

      @arguments each (a):
        a bytecode(g)

      when(splat):
        splat bytecode(g)
        g case-array

      if(block)
        then: block bytecode(g)
        else: g push-nil

      g send-super(nil, @arguments size, splat)
