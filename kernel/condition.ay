namespace(atomy)

title"Condition System"

doc"
Rather than traditional exceptions, Atomy sports a condition/restart system \
modeled on Common Lisp's design. The native Ruby exception handling is \
available, but conditions and restarts are much more flexible.
"

-- registered handlers/restarts
dynamic(handlers, [])
dynamic(restarts, [])

for-macro:
  catcher(x) :=
    x match:
      Atomy::AST::Variable ->
        Atomy::AST::Variable new(x line, "restart:" + x name)

      Atomy::AST::Send ->
        Atomy::AST::Variable new(x line, "restart:" + x method-name)

data(Object):
  Restart(@name, @action)

Restart invoke(*args) :=
  throw(("restart:" + @name to-s) to-sym, @action [*args])

symbols(signal, warning, error, restart)

section("Conditions"):
  doc"Condition system hierarchy. You should subclass one of these to create \
  your own conditions." for:
    data(Object):
      Condition:
        Error:
          SimpleError(@value)
          ExceptionError(@exception)
          NoRestartError(@name)

        Warning:
          SimpleWarning(@value)

  doc"Get the name of a condition. By default, this will be the class name, \
  but you may override this for your own behaviour." for:
    Condition name := class name

    ExceptionError name := @exception class name

  doc"A human-friendly  message displayed for the condition. \
  Override this." for:
    Condition message := inspect

    SimpleError message := @value to-s
    ExceptionError message := @exception message
    SimpleWarning message := @value to-s
    NoRestartError message := "unknown restart " + @name show


section("Handling"):
  doc"
    Trigger the \hl{name} restart, passing \hl{args} along to its callback.

    See \hl{with-restarts}.
  " spec {
    name is-a?(Symbol)
    => any
  } for {
    restart(name, *args) := do:
      ^restarts each [r]:
        when(r name == name):
          r invoke(*args)

      error(NoRestartError new(name))
  } examples:
    { with-restarts(foo -> 42):
        signal(#bar)
    } bind: #bar -> restart(#foo)


  doc"
    Register handlers for various signals for the duration of \hl{x}'s execution.

    The body of \hl{y} is similar to \hl{match}; \hl{\italic{pattern} -> \italic{body}}.

    The result is the result of \hl{body}.
  " spec {
    y contents all? [x]: x match { `(~_ -> ~_) -> true, _ -> false }
    => any
  } for {
    macro(body bind(&y)):
      names [a]:
        callback = `([~a]: ~a match: ~*(y contents))
        `(let(handlers = ^handlers + [~callback]):
            ~body rescue:
              (e: StandardError) -> error(e))
  } examples:
    { signal(#a) } bind: #a -> "got A!" print
    { signal(#b) } bind: #a -> "got A!" print
    { { signal(#a) } bind: #a -> "inner" print } bind: #a -> "outer" print


  doc"
    Register restarts available for the duration of \hl{body}'s execution.

    The \hl{restarts} should be in the form of \hl{\italic{name}(*\italic{args}) -> \italic{body}}.

    The result is the result of \hl{body}.
  " spec {
    => any
  } for {
    macro(with-restarts(*restarts, &block)):
      rs = restarts collect [`(~n -> ~e)]:
        n match:
          Atomy::AST::Variable ->
            `(Restart new(#~n, { ~e }))

          Atomy::AST::Send -> do:
            name = Atomy::AST::Variable new(0, n method-name)
            `(Restart new(#~name, [~*(n arguments)] { ~e }))

      body =
        restarts reduce(
          `{ ~block rescue: (e: StandardError) -> error(e) }
        ) [x, `(~name -> ~_)]:
          `{ catch(#~catcher(name), &~x) }

      `(let(restarts = [~*rs] + ^restarts, &~body))
  } examples:
    { with-restarts(x -> 1, y -> 2):
        signal(#a)
    } bind: #a -> restart(#x)

    { with-restarts(x -> 1, y -> 2):
        signal(#a)
    } bind: #a -> restart(#y)

    { with-restarts(x(a) -> a * 7):
        signal(#a)
    } bind: #a -> restart(#x, 6)


section("Signalling"):
  doc"
    Signal a value through all bound handlers, nearest-first, stopping when one triggers a restart.
  " spec {
    => nil
  } for {
    signal(c) := do:
      ^handlers reverse-each [callback]:
        callback [c]

      nil
  } examples:
    signal(#foo)
    { signal(#foo) } bind: #foo -> "got foo" print


  doc"
    Like \hl{signal}, except that if no restart is triggered, the current \hl{^debugger} is started.

    If the given value is not an \hl{Error}, it is wrapped in a \hl{SimpleError}. If the value is a Ruby \hl{Exception}, it is wrapped in an \hl{ExceptionError}.
  " spec {
    => _
  } for {
    error(v) := error(SimpleError new(v))
    error(e: Exception) := error(ExceptionError new(e))
    error(e: Error) := do:
      signal(e)

      with-output-to(^error-port):
        ^debugger run(e)
  } examples:
    error("Oh no!")
    { error("Oh no!") } bind: Error -> "INCOMING" print


  doc"
    Like \hl{signal}, except that if no restart is triggered, the warning is printed to \hl{^error-port}.

    If the given value is not a \hl{Warning}, it is wrapped in a \hl{SimpleWarning}. Warning messages can be muffled by binding for \hl{Warning} and triggering the \hl{#muffle-warning} restart.
  " spec {
    => nil
  } for {
    warning(v) := warning(SimpleWarning new(v))
    warning(w: Warning) :=
      with-restarts(muffle-warning -> nil):
        signal(w)

        with-output-to(^error-port):
          w message print

        nil
  } examples:
    warning("Suspicious!")
    { warning("Quiet, you!") } bind: Warning -> restart(#muffle-warning)


section("Debuggers"):
  doc"
    The default debugger. This will show the condition name, its message, \
    and let the user pick from the available restarts." for:
    class(DefaultDebugger):
      class(<< self):
        define(show-error-banner(e)):
          ("-" * 78) print
          (e name + ": " + e message) each-line [l]:
            ("*** " + l) display

          "\n" display

        define(show-options-for(e)):
          when(^restarts empty?):
            exit(1)

          "\n" display
          "restarts:" print
          ^restarts each-with-index [r, i]:
            ("  :" + i to-s + " -> " + r name to-s) print

        define(run(e)):
          show-error-banner(e)

          show-options-for(e)

          "!> " display
          ^restarts [gets to-i] invoke


  doc"
    The current debugger. This should \hl{respond-to?(#run)} with the \
    condition passed as an argument." for:
    dynamic(debugger, DefaultDebugger)
