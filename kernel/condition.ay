use("core")
define = use("define")
use("data")
use("control-flow")
use("loop")
use("interpolation")
use("array")

use("dynamic")
io = use("io")

-- registered handlers/restarts
Handlers = dynamic([])
Restarts = dynamic([])

catcher(x) := ."restart:#{define message-name(x)}"
message-name(x) := define message-name(x)
arguments(x) := define arguments(x)
block(x) := define block(x)

data(Restart(@name, @action))

Restart invoke(*args) :=
  throw(."restart:#{@name}", @action [*args])

data(Condition):
  Error(@backtrace):
    SimpleError(@value)
    ExceptionError(@exception)
    NoRestartError(@restart)
    PortError(@port):
      EndOfFile

  Warning(@backtrace):
    SimpleWarning(@value)

Condition name := class name

ExceptionError name := @exception class name

Condition message := inspect

SimpleError message := @value to-s
ExceptionError message := @exception message
SimpleWarning message := @value to-s
NoRestartError message := "unknown restart " + @restart show
EndOfFile message := "unexpected end-of-file for " + @port show


macro(~body bind { ~*handlers }):
  names [a]:
    callback = `([~a]: ~a match: ~*handlers)
    `(let(Handlers = ~callback . ^Handlers):
        ~body rescue:
          (e: StandardError) -> error(e))


macro(with-restarts(~*restarts) ~(block: Block)):
  pairs = pairs-from(restarts)

  rs = pairs collect [n, e]:
    `(Restart new(
        ~message-name(n)
        [~*arguments(n)] &~block(n) { ~e }
      ))

  body =
    pairs reduce(
      `{ ~block rescue: (e: StandardError) -> error(e) }
    ) [x, [name, _]]:
      `{ catch(~catcher(name)) ~x }

  `(let(Restarts = [~*rs] + ^Restarts) ~body)


export

restart(name, *args) := do:
  ^Restarts each [r]:
    when(r name == name):
      r invoke(*args)

  error(NoRestartError new(name))


signal(c) := do:
  hs = ^Handlers dup

  until(hs empty?):
    callback = hs shift
    let(Handlers = hs):
      callback [c]

  nil


error(x) := do:
  e =
    x match:
      Exception ->
        ExceptionError new(x) tap [err]:
          err backtrace = x locations

      Error ->
        x tap [err]:
          err backtrace = Rubinius::VM backtrace(0)

      _ ->
        SimpleError new(x) tap [err]:
          err backtrace = Rubinius::VM backtrace(0)

  signal(e)

  with-output-to(^io::ErrorPort):
    ^Debugger run(e)


warning(x) :=
  with-restarts(muffle-warning -> nil):
    w =
      x match:
        Warning ->
          x tap [wrn]:
            wrn backtrace = Rubinius::VM backtrace(0)

        _ ->
          SimpleWarning new(x) tap [wrn]:
            wrn backtrace = Rubinius::VM backtrace(0)

    signal(w)

    with-output-to(^io::ErrorPort):
      (w name + ": " + w message) println

    nil


DefaultDebugger = class:
  singleton:
    define(show-error-banner(e)):
      ("-" * 78) println
      (e name + ": " + e message) each-line [l]:
        ("*** " + l) display

      "\n" display

    define(show-options-for(e)):
      when(^Restarts empty?):
        exit(1)

      "\n" display
      "restarts:" println
      ^Restarts each-with-index [r, i]:
        ("  :" + i to-s + " -> " + r name to-s) println

    define(run(e)):
      show-error-banner(e)

      show-options-for(e)

      "!> " display
      ^Restarts [gets to-i] invoke

Debugger = dynamic(DefaultDebugger)
