use("core")
define = use("define")
use("data")
use("control-flow")
use("loop")
use("interpolation")
use("array")

use("dynamic")

io = require("io")
pretty = require("pretty")

data(Handler(@callback, @rest = nil)):
  BaseHandler()

-- registered handlers/restarts
Handlers = dynamic(BaseHandler new)
Restarts = dynamic([])

catcher(x) = ."restart:#{define message-name(x)}"
message-name(x) = define message-name(x)
arguments(x) = define arguments(x)
block(x) = define block(x)

data(Restart(@name, @action))

Restart invoke(*args) :=
  throw(."restart:#{@name}", @action [*args])

data(Condition):
  Error(@backtrace):
    SimpleError(@value)
    ExceptionError(@exception)
    NoRestartError(@restart)
    PortError(@port):
      EndOfFile

  Warning(@backtrace):
    SimpleWarning(@value)

Condition name := class name

ExceptionError name := @exception class name

Condition message := inspect

SimpleError message := @value to-s
ExceptionError message := @exception message
SimpleWarning message := @value to-s
NoRestartError message := "unknown restart " + pretty show(@restart)
EndOfFile message := "unexpected end-of-file for " + pretty show(@port)


macro(~body bind { ~*handlers }):
  names [a]:
    callback = `([~a]: ~a match: ~*handlers)
    `(let(Handlers = Handler new(~callback, ^Handlers)):
        ~body rescue:
          (e: StandardError) -> Self error(e))


macro(with-restarts(~*restarts) ~(block: Block)):
  pairs = pairs-from(restarts)

  rs = pairs collect [n, e]:
    `(Restart new(
        ~message-name(n)
        [~*arguments(n)] &~block(n) { ~e }))

  body =
    pairs reduce(`{ ~block rescue: (e: StandardError) -> Self error(e) })
      [x, [name, _]]:
        `{ catch(~catcher(name)) ~x }

  `(let(Restarts = [~*rs] + ^Restarts) ~body)


restart(name, *args) := do:
  ^Restarts each [r]:
    when(r name == name):
      r invoke(*args)

  error(NoRestartError new(name))


BaseHandler signal(_) := nil
Handler(callback, rest) signal(c) :=
  let(Handlers = rest):
    callback [c]
    rest signal(c)

signal(c) := ^Handlers signal(c)

error(x) := do:
  e =
    x match:
      Exception ->
        ExceptionError new(x) tap [err]:
          err backtrace = x locations

      Error ->
        x tap [err]:
          err backtrace = Rubinius VM backtrace(0)

      _ ->
        SimpleError new(x) tap [err]:
          err backtrace = Rubinius VM backtrace(0)

  signal(e)

  with-output-to(^(io ErrorPort)):
    ^Debugger run(e)


warning(x) :=
  with-restarts(muffle-warning -> nil):
    w =
      x match:
        Warning ->
          x tap [wrn]:
            wrn backtrace = Rubinius VM backtrace(0)

        _ ->
          SimpleWarning new(x) tap [wrn]:
            wrn backtrace = Rubinius VM backtrace(0)

    signal(w)

    with-output-to(^(io ErrorPort)):
      puts(w name + ": " + w message)

    nil


-- TODO: this is awkward
DefaultDebugger = class:
  singleton:
    define(show-error-banner(e)):
      puts("-" * 78)
      (e name + ": " + e message) split("\n") each [l]:
        puts("*** " + l)

    define(show-options-for(e)):
      when(^Restarts empty?):
        exit(1)

      puts("")
      puts("restarts:")
      ^Restarts each-with-index [r, i]:
        puts("  :" + i to-s + " -> " + r name to-s)

    define(run(e)):
      show-error-banner(e)

      show-options-for(e)

      print("!> ")
      ^Restarts [gets to-i] invoke

Debugger = dynamic(DefaultDebugger)
